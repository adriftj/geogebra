/*
GeoGebra - Dynamic Mathematics for Everyone
Copyright Markus Hohenwarter, http://www.geogebra.org

This file is part of GeoGebra.

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by 
the Free Software Foundation; either version 2 of the License, or 
(at your option) any later version.
*/

/*
 * Parser.jj
 * javacc definition file to generate Parser.java
 * <BR> <BR>
 * This class provides a static function to
 * parse a String and return an appropriate ValidExpression.
 * Direct subclasses of ValidExpression are:
 * Command, Equation (in x, y), Parametric, Vector (for cartesian and polar points),
 * ExpressionNode (for number or vector arithmetic expressions)
 *
 * <BR><BR>
 * Some examples of possible recognized input:<BR>
 * Point   <CODE> P = (3,4) </CODE><BR>
 * Point   <CODE> P = (7; 20?) </CODE><BR>
 * Line    <CODE> g: X = (3,4) + t (7,2) </CODE><BR>
 * Line    <CODE> g: y = 3x - 9 </CODE><BR>
 * Line    <CODE> h: 5x + 7y = -2 </CODE><BR>
 * Circle  <CODE> k: (x-5)^2 + (y-2)^2 = 25 </CODE><BR>
 * Circle  <CODE> k: (x-5)? + (y-2)? = 25 </CODE><BR>
 * Conic   <CODE> c: 5x^2 - 7y^2 + 6xy - 3x + 2y = 7 </CODE>
 * Command <CODE> P = Intersect[ g, h ] </CODE>
 * Number  <CODE> r = 25 </CODE>
 * <BR><BR>
 * All arithmetic expressions (operators: +, -, *, /, ^) are
 * valid as long as they obey the following rules:
 * Variables are x or y. Divisors and Exponents must be constant
 * numbers. The "*" operator may be omitted.
 *
 * @author Markus Hohenwarter
 * @version 10.4.2004
 */


options {
   STATIC = false;
   JAVA_TEMPLATE_TYPE = "modern";
   //DEBUG_PARSER = true;
   //DEBUG_LOOKAHEAD = true;
   //DEBUG_TOKEN_MANAGER = true;
}

PARSER_BEGIN(Parser)
package org.geogebra.common.kernel.parser;

import org.geogebra.common.kernel.Construction;
import org.geogebra.common.kernel.arithmetic.*;
import org.geogebra.common.kernel.arithmetic.variable.Variable;
import org.geogebra.common.kernel.arithmetic3D.MyVec3DNode;
import org.geogebra.common.kernel.commands.Commands;
import org.geogebra.common.kernel.geos.GeoSymbolicI;
import org.geogebra.common.kernel.geos.GeoElement;
import org.geogebra.common.kernel.geos.GeoElementSpreadsheet;
import org.geogebra.common.kernel.geos.GeoNumeric;
import org.geogebra.common.kernel.parser.ParserInterface;
import org.geogebra.common.kernel.StringTemplate;
import org.geogebra.common.main.MyError;
import org.geogebra.common.main.Localization;
import org.geogebra.common.main.BracketsError;
import org.geogebra.common.util.StringUtil;
import org.geogebra.common.util.debug.Log;
import com.himamis.retex.editor.share.util.Unicode;
import org.geogebra.common.kernel.Kernel;
import org.geogebra.common.kernel.parser.cashandlers.CommandDispatcherGiac;
import org.geogebra.common.main.App;
import org.geogebra.common.plugin.Operation;
import org.geogebra.common.gpad.GpadStyleSheet;
import org.geogebra.common.gpad.GpadParseException;
import org.geogebra.common.gpad.GpadSerializer;
import org.geogebra.common.io.GpadStyleXMLApplier;
import org.geogebra.common.kernel.commands.EvalInfo;
import org.geogebra.common.kernel.CircularDefinitionException;
import java.util.Map;
import org.geogebra.common.gpad.GpadStyleMaps;
import org.geogebra.common.kernel.Macro;
import org.geogebra.common.kernel.MacroKernel;
import org.geogebra.common.gpad.GpadParser;

import java.util.ArrayList;
import java.util.Vector;

import com.google.j2objc.annotations.Weak;

@SuppressWarnings("javadoc")
public class Parser implements ParserInterface {

    @Weak
    private Kernel kernel;
    @Weak
    private App app;
    private Localization loc;

    private boolean geoGebraCASParsing = false;
    private boolean externalCASParsing = false;
    private boolean giacParsing = false;

    private boolean enableStructures = true;
    private FunctionParser functionParser;
    private final ArrayList<ExpressionNode> undecided = new ArrayList<ExpressionNode >();
    private boolean highPrecisionParsing;
    private int nestedCommands = 0;
    
    // Gpad parsing state
    private java.util.Map<String, GpadStyleSheet> gpadStyleSheets;
    private java.util.List<GeoElement> gpadResults;
    private java.util.List<String> gpadWarnings;

    /**
     * Constructor for expression validation (without Kernel).
     * Used for checking if expressions are "simple" according to grammar rules.
     */
    public Parser() {
        this ( new StringProvider("") ); // dummy stream for parser initing
        this.kernel = null;
        this.functionParser = null;
        this.app = null;
        this.loc = null;
        highPrecisionParsing = false;
    }

    public Parser(Kernel kernel) {
        this ( new StringProvider("") ); // dummy stream for parser initing
        this.kernel = kernel;
        functionParser = new FunctionParser(kernel, undecided);
        app = kernel.getApplication();
        loc = app.getLocalization();
        highPrecisionParsing = false;
    }

    /**
     * Needed to prevent memory leaks in Web
     * @return the static exception instance
     */
    public static Throwable getLookaheadSuccess() {
       return jj_ls;
    }

	public Kernel getKernel() {
		return kernel;
	}

	private void myReInit(String parseString) {
		myReInit(parseString, false);
	}

	// reset for new parsing
	private void myReInit(String parseString, boolean inputBox) {
		if (!kernel.getConstruction().isFileLoading() && StringUtil.checkBracketsBackward(StringUtil.ignoreIndices(parseString)) >= 0) {
			throw new BracketsError(loc,parseString);
		}
		boolean decimalComma = !inputBox || loc.isUsingDecimalComma();
		String input = StringUtil.preprocessWithInfo(parseString, new ParserInfo(inputBox, decimalComma));
		ReInit(new StringProvider(input.trim()));
		geoGebraCASParsing = false;
		externalCASParsing = false;
		giacParsing = false;
		highPrecisionParsing = true;
		nestedCommands = 0;
		functionParser.setInputBoxParsing(false);
		enableStructures = kernel.getAlgebraProcessor().enableStructures();
		undecided.clear();
	}

	/**
	 * Parses a String and returns a ValidExpression Object
	 */
	@Override
	public ValidExpression parseGeoGebraExpression(String parseString) throws ParseException {
		myReInit(stripEqualSign(parseString));
		ValidExpression ret = buildValidExpression();
		processUndecided();
		// most commands are wrapped at this point, except for CellRange that was created as A1:A9
		return ret instanceof Command ? ret.wrap() : ret;
	}

	@Override
	public ValidExpression parseGeoGebraExpressionLowPrecision(String parseString) throws ParseException {
		myReInit(stripEqualSign(parseString));
		highPrecisionParsing = false;
		ValidExpression ret = buildValidExpression();
		processUndecided();
		return ret;
	}

	@Override
	public ValidExpression parseInputBoxExpression(String parseString) throws ParseException {
    	myReInit(stripEqualSign(parseString), true);
    	functionParser.setInputBoxParsing(true);
		ValidExpression ret = buildValidExpression();
		processUndecided();
		return ret;
	}

	private String stripEqualSign(String parseString) {
		return parseString.length() > 0 && parseString.charAt(0) == '=' ? parseString.substring(1) : parseString;
	}

     /**
     * Parses a String and returns a ValidExpression Object
     */
    public ValidExpression parseGeoGebraCAS(String parseString, GeoSymbolicI cell) throws ParseException {
        myReInit( parseString );
        // parse x^2 + y^2 as an expression and don't throw Incomplete Equation error
        geoGebraCASParsing = true;
        ValidExpression ret = buildCASExpression(cell);
        processUndecided();
        return ret;
    }

    /**
     * Parses a Giac String and returns a ValidExpression Object
     */
    public ValidExpression parseGiac(String parseString) throws ParseException {
        myReInit( parseString );
        externalCASParsing = true;
        giacParsing = true;
        return buildGiacExpression();
    }

    /**
     * Parses a String and returns a Function Object
     */
	@Override
    public Function parseFunction(String parseString)
    throws ParseException {
        myReInit( parseString );
        Function ret = function();
        processUndecided();
        return ret;
    }

    /**
     * Parses a String and returns a Function Object
     */
	@Override
    public FunctionNVar parseFunctionNVar(String parseString) throws ParseException {
        myReInit( parseString );
        FunctionNVar ret = functionNVar();
        processUndecided();
        return ret;
    }

    /**
     * Parses a String and returns an ExpressionNode Object
     */
    public ExpressionNode parseCmdExpression(String parseString) throws ParseException {
        myReInit(parseString );
        nestedCommands = 1;
        ExpressionNode ret = expressionOrEquation().wrap();
        processUndecided();
        return ret;
    }

    /**
     * Parses a String and returns an ExpressionNode Object
     * Checking for free vars should be done outside.
     */
    @Override
    public ExpressionNode parseExpression(String parseString) throws ParseException {
        myReInit( parseString);
        ExpressionNode ret = expressionnode();
        processUndecided();
        return ret;
    }

    /**
     * Parses a String if it is a label
     */
    @Override
    public String parseLabel(String parseString) throws ParseException {
        myReInit(parseString );
        return label().image;
    }

    private ExpressionNode makePower(ExpressionValue v, ExpressionValue e) {
        if (v.isExpressionNode()
                && ((ExpressionNode) v)
                        .getOperation() == Operation.MULTIPLY_OR_FUNCTION
                && !((ExpressionNode) v).hasBrackets()) {
            return new ExpressionNode(kernel, ((ExpressionNode) v).getLeft(),
                    Operation.MULTIPLY,
                    new ExpressionNode(kernel, ((ExpressionNode) v).getRight(),
                            Operation.POWER, e));
        }
        if (v.unwrap() instanceof Command
                && kernel.getSymbolicMode() == SymbolicMode.SYMBOLIC_AV
                && !((ExpressionNode) v).hasBrackets()) {
            Command cmd = (Command) v.unwrap();
            if (cmd.getArgumentNumber() == 1 && Commands.stringToCommand(cmd.getName()) == null) {
                return new ExpressionNode(kernel, new Variable(kernel, cmd.getName()),
                    Operation.MULTIPLY,
                    new ExpressionNode(kernel, cmd.getArgument(0),
                            Operation.POWER, e));
            }
        }
        return new ExpressionNode(kernel, v, Operation.POWER, e);
    }

    private void processUndecided() {
        for (ExpressionNode en: undecided) {
            en.setOperation(Operation.MULTIPLY);
        }
        undecided.clear();
    }

    private <T extends ExpressionValue> T ifStructuresEnabled(T def)
            throws MyError {
        if (enableStructures) {
            return def;
        }
        throw new MyError(loc, MyError.Errors.InvalidInput);
    }

    private MyDouble parseDouble(String image, boolean percent) {
        double val = MyDouble.parseDouble(loc, image);
        if (percent) {
            val = val * 0.01;
        }
        if (externalCASParsing || geoGebraCASParsing || highPrecisionParsing) {
            // preserve string from CAS: it may have higher
            // precision than double
            return new MySpecialDouble(kernel, val, percent ? image + "%" : image, externalCASParsing);
        }

        return new MyDouble(kernel, val);
    }

    private double parseDouble(Token c) {
        return MyDouble.parseDouble(loc, c.image);
    }

    private MyDouble newSpecialDegree() {
        MyDouble d = new MySpecialDouble(kernel, Math.PI / 180.0d, "\u00b0");
        d.setAngle();
        return d;
    }

    private RecurringDecimal parseRecurringDecimal(String imagePreperiod, String imageRecurring) {
        return RecurringDecimal.parse(kernel, imagePreperiod,
            imageRecurring.replace(String.valueOf(Unicode.OVERLINE), ""));
    }

    /**
    * Error recovery: skip invalid tokens until ";" or "}" or EOF
    * Collects warning information about skipped tokens.
    */
    void gpadSkipToSync() {
        token_source.SwitchTo(DEFAULT);
        Token currentToken = getToken(0);
        int startLine = currentToken != null ? currentToken.beginLine : -1;
        int startColumn = currentToken != null ? currentToken.beginColumn : -1;
        Token t = getToken(1);
        StringBuilder skippedTokens = new StringBuilder();
        boolean firstToken = true;
        
        while (t.kind != POLAR_SEPARATOR && t.kind != RBRACE && t.kind != EOF) {
            if (!firstToken)
                skippedTokens.append(" ");
            skippedTokens.append(t.image);
            firstToken = false;
            getNextToken();
            t = getToken(1);
        }
        
        if (skippedTokens.length() > 0) {
            String warningMsg = "Skipped invalid tokens: " + skippedTokens.toString();
            addGpadWarning(warningMsg, startLine, startColumn);
        }
    }

    // 使用 GpadStyleMaps 中定义的映射表
    private static final Map<String, String> gkUniqueAttrs = GpadStyleMaps.GPAD_TO_XML_ATTR_NAME_MAP;
    private static final Map<String, String> gkNameMaps = GpadStyleMaps.GPAD_TO_XML_NAME_MAP;
    private static final Map<String, String> gkStartEndStyleValues = GpadStyleMaps.START_END_STYLE_VALUES;
    private static final Map<String, String> gkRevertBooleanValues = GpadStyleMaps.BOOLEAN_VALUE_REVERT_MAP;
    private static final Map<String, String> gkEqnStyleValues = GpadStyleMaps.EQN_STYLE_VALUES;
    private static final Map<String, String> gkLineStyleTypeValues = GpadStyleMaps.LINE_STYLE_TYPE_MAP;
    private static final Map<String, String> gkLineStyleTypeHiddenValues = GpadStyleMaps.LINE_STYLE_TYPE_HIDDEN_MAP;
    private static final Map<String, Map<String, String>> gkValueMaps = GpadStyleMaps.VALUE_MAPS;

    /**
     * Helper method to convert property key name and determine attribute name.
     * 
     * @param keyName the original key name from token
     * @return String array with [propertyName, attrName]
     */
    private String[] convertPropertyKey(String keyName) {
        // First, determine the attribute name (check gkUniqueAttrs)
        String attrName = gkUniqueAttrs.getOrDefault(keyName, "val");
        // Then convert the property name (check gkNameMaps)
        String propertyName = gkNameMaps.getOrDefault(keyName, keyName);
        return new String[]{propertyName, attrName};
    }

    /**
     * Helper method to convert property value and set it to style sheet.
     * Handles value conversion through gkValueMaps with error tolerance.
     * 
     * @param styleSheet the style sheet to set property
     * @param key original property name
     * @param originalValue the original value to convert
     */
    private void setPropertyWithValueConversion(GpadStyleSheet styleSheet, 
            String key, String originalValue) {
        String converted[] = convertPropertyKey(key);
        // Check gkValueMaps for value conversion
        String finalValue;
        Map<String, String> valueMap = gkValueMaps.get(converted[0]);
        if (valueMap == null) // No value map found, use original
            finalValue = originalValue;
        else {
            // Check if original value is in the map
            finalValue = valueMap.get(originalValue);
            if (finalValue == null) // Value not found, skip
                return;
        }
        // Write to style sheet
        java.util.LinkedHashMap<String, String> attrs = new java.util.LinkedHashMap<>();
        attrs.put(converted[1], finalValue);
        styleSheet.setProperty(converted[0], attrs);
    }

    /**
     * Parses a Gpad program and returns a list of GeoElements.
     * 
     * @param gpadText Gpad text to parse
     * @return list of created GeoElements
     * @throws ParseException if parsing fails
     */
    public java.util.List<GeoElement> parseGpad(String gpadText) throws GpadParseException {
        if (gpadText == null || gpadText.trim().isEmpty())
            return new java.util.ArrayList<>();
        gpadStyleSheets = new java.util.HashMap<>();
        gpadResults = new java.util.ArrayList<>();
        gpadWarnings = new java.util.ArrayList<>();
        
        try {
            myReInit(gpadText);
            buildGpadProgram();
            return gpadResults;
        } catch (ParseException e) {
            throw createGpadParseException(e);
        } catch (Throwable t) {
            // Catch any other exceptions (CircularDefinitionException and MyError should already be
            // caught and converted to GpadParseException by gpadCommandExpression)
            throw createGpadParseException(t, t.getClass().getSimpleName(), -1, -1, false);
        }
    }
    
    /**
     * Adds a warning message with position information.
     * 
     * @param message warning message
     * @param line line number (1-based), or -1 if unknown
     * @param column column number (1-based), or -1 if unknown
     */
    private void addGpadWarning(String message, int line, int column) {
        if (gpadWarnings == null)
            gpadWarnings = new java.util.ArrayList<>();
        gpadWarnings.add(buildDetailedErrorMessage(message, line, column, false));
    }
    
    /**
     * Adds a warning message without position information.
     * 
     * @param message warning message
     */
    private void addGpadWarning(String message) {
        addGpadWarning(message, -1, -1);
    }
    
    /**
     * @return the list of warnings collected during Gpad parsing
     */
    public java.util.List<String> getGpadWarnings() {
        return gpadWarnings;
    }
    
    /**
     * @return the global style sheets for Gpad
     */
    public java.util.Map<String, GpadStyleSheet> getGpadStyleSheets() {
        return gpadStyleSheets;
    }

    /**
     * Parses a hex color string (#rrggbb or #rrggbbaa) to 4-element array.
     * @param colorHex the hex color string (e.g., "#FF0000" or "#FF0000FF")
     * @param rgba the array to store [0]=r, [1]=g, [2]=b, [3]=alpha
     */
    private void parseHexColorToArray(String colorHex, int[] rgba) {
        if (colorHex != null && colorHex.startsWith("#")) {
            String colorUpper = colorHex.toUpperCase();
            int len = colorUpper.length();
            if(len == 7 || len == 9) {
                try {
                    int r = Integer.parseInt(colorUpper.substring(1, 3), 16);
                    int g = Integer.parseInt(colorUpper.substring(3, 5), 16);
                    int b = Integer.parseInt(colorUpper.substring(5, 7), 16);
                    // Parse hex color #rrggbb (alpha defaults to 1.0) or #rrggbbaa
                    rgba[3] = len==9? Integer.parseInt(colorUpper.substring(7, 9), 16): -1;
                    rgba[0] = r; rgba[1] = g; rgba[2] = b;
                    return;
                } catch (NumberFormatException e) {
                    // Invalid format
                }
            }
        }
        rgba[0] = rgba[1] = rgba[2] = rgba[3] = -1;
    }


    /**
     * Parses a hex color string (#rrggbb or #rrggbbaa) and populates the attrs map.
     * @param colorHex the hex color string (e.g., "#FF0000" or "#FF0000FF")
     * @param attrs the map to populate with r, g, b, and alpha values
     * @return true if the color was successfully parsed, false otherwise
     */
    private boolean parseHexColor(String colorHex, java.util.LinkedHashMap<String, String> attrs) {
        int[] rgba = new int[4];
        parseHexColorToArray(colorHex, rgba);
        if (rgba[0]<0 || rgba[1]<0 || rgba[2]<0)
            return false;
        attrs.put("r", String.valueOf(rgba[0]));
        attrs.put("g", String.valueOf(rgba[1]));
        attrs.put("b", String.valueOf(rgba[2]));
        if (rgba[3] >= 0)
            attrs.put("alpha", String.valueOf(rgba[3]/255.0));
        return true;
    }

    /**
     * Extracts the value after "=" in a token string, skipping spaces and tabs.
     * @param tokenImage the full token string (e.g., "fill = hatch" or "angle=30")
     * @return the value after "=" with leading spaces/tabs removed, or null if "=" not found
     */
    private String extractValueAfterEquals(String tokenImage) {
        int equalsIndex = tokenImage.indexOf('=');
        if (equalsIndex < 0)
            return null;
        // Find the start of the value (skip spaces/tabs after =)
        int valueStart = equalsIndex + 1;
        while (valueStart < tokenImage.length() && (tokenImage.charAt(valueStart) == ' ' || tokenImage.charAt(valueStart) == '\t')) {
            valueStart++;
        }
        return tokenImage.substring(valueStart);
    }

    /**
     * Unescapes a quoted string by processing escape sequences.
     * Handles: \\n -> \n, \\r -> \r, \\t -> \t, \\" -> ", \\\\ -> \
     * @param quoted the string with escape sequences (already with quotes removed)
     * @return the unescaped string
     */
    private static String unescapeString(String quoted) {
        return quoted.replace("\\n", "\n")
                     .replace("\\r", "\r")
                     .replace("\\t", "\t")
                     .replace("\\\"", "\"")
                     .replace("\\\\", "\\");
    }

    /**
     * Extracts the integer part from a float token string.
     * Removes the decimal part if present (e.g., "12.5" -> "12", "10" -> "10").
     * @param floatStr the float string from GK_VALUE_float token
     * @return the integer part as a string
     */
    private static String extractIntegerPart(String floatStr) {
        int dotIndex = floatStr.indexOf('.');
        return dotIndex >= 0 ? floatStr.substring(0, dotIndex) : floatStr;
    }

    /**
     * Extracts line and column information from a Token.
     * @param token the token to extract position from (can be null)
     * @return array with [line, column], both -1 if token is null or unavailable
     */
    private int[] extractPositionFromToken(Token token) {
        try {
            return new int[]{token.beginLine, token.beginColumn};
        } catch (Exception ex) {
            return new int[]{-1, -1};
        }
    }

    /**
     * Builds a detailed error message with position information.
     * @param errorMsg the base error message
     * @param line line number (1-based), or -1 if unknown
     * @param column column number (1-based), or -1 if unknown
     * @param checkExistingPosition if true, checks if errorMsg already contains position info
     * @return detailed error message with position prefix if applicable
     */
    private String buildDetailedErrorMessage(String errorMsg, int line, int column, 
            boolean checkExistingPosition) {
        if (checkExistingPosition && errorMsg.startsWith("Line "))
            return errorMsg;
        StringBuilder detailedMsg = new StringBuilder();
        if (line >= 0 && column >= 0)
            detailedMsg.append("Line ").append(line).append(", column ")
                    .append(column).append(": ");
        else if (line >= 0)
            detailedMsg.append("Line ").append(line).append(": ");
        detailedMsg.append(errorMsg);
        return detailedMsg.toString();
    }

    /**
     * Creates a GpadParseException with position information.
     * @param t error/exception
     * @param line line number (1-based), or -1 if unknown
     * @param column column number (1-based), or -1 if unknown
     * @param checkExistingPosition if true, checks if errorMsg already contains position info
     * @return GpadParseException with detailed message and position
     */
    private GpadParseException createGpadParseException(Throwable t,
            String fallbackMsg, int line, int column, boolean checkExistingPosition) {
        String errorMsg = t.getLocalizedMessage();
        if (errorMsg==null)
            errorMsg = fallbackMsg;
        String detailedMsg = buildDetailedErrorMessage(errorMsg, line, column, checkExistingPosition);
        return new GpadParseException(detailedMsg, line, column);
    }

    /**
     * Creates a GpadParseException with ParseException.
     * @param e ParseException
     * @return GpadParseException with detailed message and position
     */
    private GpadParseException createGpadParseException(ParseException e) {
        int[] pos = extractPositionFromToken(e.currentToken);
        return createGpadParseException(e, "Parse error", pos[0], pos[1], true);
    }

    /**
     * Creates a ParseException with position information extracted from a Token.
     * @param errorMsg the base error message
     * @param token the token to extract position from (can be null)
     * @return ParseException with detailed message and currentToken set
     */
    private ParseException createParseException(String errorMsg, Token token) {
        int[] pos = extractPositionFromToken(token);
        String detailedMsg = buildDetailedErrorMessage(errorMsg, pos[0], pos[1], false);
        ParseException pe = new ParseException(detailedMsg);
        pe.currentToken = token;
        return pe;
    }

    private void applyGeoStyleSheet(GeoElement geo, GpadStyleSheet styleSheet, int line, int column) {
        java.util.ArrayList<String> errors = GpadStyleXMLApplier.apply(styleSheet, geo);
        // Merge all errors into a single warning - allow parsing to continue
        if (errors != null && !errors.isEmpty()) {
            StringBuilder warningMsg = new StringBuilder();
            warningMsg.append("Failed to apply style sheet to ").append(geo.getLabelSimple()).append(": ");
            boolean first = true;
            for (String errorMsg : errors) {
                if (!first)
                    warningMsg.append("; ");
                first = false;
                warningMsg.append(errorMsg);
            }
            // Use command expression position for warning
            addGpadWarning(warningMsg.toString(), line, column);
        }
    }
}
PARSER_END(Parser)


// Note: includes all Unicode whitespaces (incl. non-breaking), separators and ZWSP
<*> SKIP : {
  <(["\u0009" - "\u000E", // ASCII spaces, \u000E added to work around JavaCC bug
  "\u001C" - "\u0020", // separators
  "\u1680",
  "\u2000" - "\u200B", "\u2028" , "\u2029", "\u205F", // various width spaces, including ZWSP
  "\u00A0", "\u202F", // non-breaking spaces
  "\u3000", // ideographic space
  "\uFEFF" // BOM
  ])> 
  | <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")?> // Single-line comment for Gpad
}

<*> TOKEN: {
   < #GLABEL:
    <LETTER> ( <INDEX> | <LETTER> | <DIGIT> | "'" | "‘" | "’" )* ("." <GINTEGER>)?>
 |  < #INDEX:  "_" (  <CHAR>  | ("{" (~["}"])+ "}" ) )  >
 | < #GINTEGER: ( <DIGIT> )+ >
 | < #LETTER:  // unicode letters
       [
        "$",                    // for absolute references in the spreadsheet
        "\u0041"-"\u005a",      // upper case (A-Z)
        "\u0061"-"\u007a",      // lower case (a-z)
        "\u00b7",               // middle dot (for Catalan)
        "\u00a5"-"\u00aa",      // for CAS labels
        "\u00c0"-"\u00d6",      // accentuated letters
        "\u00d8"-"\u00f6",      // accentuated letters
        "\u00f8"-"\u01bf",      // accentuated letters
        "\u01c4"-"\u02a8",      // accentuated letters
        "\u038e"-"\u03f5",      // Greek
        "\u0401"-"\u0481",      // Cyrillic
        "\u0490"-"\u04f9",      // Cyrillic
        "\u0531"-"\u167F", "\u1681"-"\u1ffc",      // a lot of signs (Arabic, accentuated, ...)
        "\u3041"-"\u3357",      // Asian letters
        "\u4e00"-"\ud7a3",      // Asian letters
        "\uf71d"-"\ufa2d",      // Asian letters
        "\ufb13"-"\ufdfb",      // Armenian, Hebrew, Arabic
        "\ufe80"-"\ufefc",      // Arabic
        "\uff66"-"\uff9d",      // Katakana
        "\uffa1"-"\uffdc"       // Hangul
       ] >
 | < #DIGIT:                                     // unicode digits
         [
          "\u0030"-"\u0039", // Arabic (=Latin)
          "\u0660"-"\u0669", // Arabic-Indic
          "\u06f0"-"\u06f9", // Extended Arabic-Indic
          "\u0966"-"\u096f", // Devanagari (Hindi)
          "\u09e6"-"\u09ef", // Bengali
          "\u0a66"-"\u0a6f", // Gurmukhi (Punjabi)
          "\u0ae6"-"\u0aef", // Gujurati
          "\u0b66"-"\u0b6f", // Oryia
          "\u0be6"-"\u0bef", // Tamil
          "\u0c66"-"\u0c6f", // Telugu
          "\u0ce6"-"\u0cef", // Kannada
          "\u0d66"-"\u0d6f", // Malayalam
          "\u0e50"-"\u0e59", // Thai
          "\u0ed0"-"\u0ed9", // Lao
          "\u1040"-"\u1049", // Myanmar (Burmese)
          "\u0f20"-"\u0f29", // Tibetan
          "\u1b50"-"\u1b59", // Balinese
          "\u1bb0"-"\u1bb9", // Sudanese
          "\u1c40"-"\u1c49", // Lepcha
          "\u1c50"-"\u1c59", // Ol Chiki
          "\u17e0"-"\u17e9", // Khmer
          "\u1810"-"\u1819", // Mongolian
          "\ua8d0"-"\ua8d9"  // Saurashtra
         ]
    >
 | < #CHAR: ["\u0000"-"\u0021", "\u0023"-"\uffff"]  >
 | < #PRINTABLE_CHAR: ["\u0020" - "\u007E", "\u0080" - "\uFFFF"] >
 | < #RGBA_HEX_COLOR: "#" (["0"-"9","A"-"F","a"-"f"])+ >
}

/* OPERATORS */
TOKEN :  {
    < ASSIGNMENT: ( ":=" | "\u2254" ) >
  | < DELAYED_ASSIGNMENT: ( "::=") >
  | < VERTICAL_BAR: "|" >
  | < NOT: ("\u00ac") >
  | < OR:    ("||" | "\u2228" ) >
  | < AND:    ("&&" | "\u2227" ) >
  | < IMPLICATION:    ("->" | "\u2192") >
  | < XOR:    ("\u22bb" | "\u2295") >
  | < SEQUENCE_OPERATOR:    ("\u2026") >
  | < EQUAL_BOOLEAN: ("==" | "\u225f" ) >
  | < NOT_EQUAL: ("!=" | "\u2260" | "<>" ) >
  | < IS_ELEMENT_OF: "\u2208" >
  | < IS_SUBSET_OF: "\u2286" >
  | < IS_SUBSET_OF_STRICT: "\u2282" >
  | < SET_DIFFERENCE: "\\" >
  | < LESS:    "<" >
  | < GREATER:  ">" >
  | < LESS_EQUAL: ("<=" | "\u2264") >
  | < GREATER_EQUAL: (">=" | "\u2265") >
 // | < INEQUALITY: ( < LESS > | < LESS_EQUAL > | < GREATER_EQUAL > | < GREATER > ) >
  | < PARALLEL: ("\u2016" |"\u2225") >
  | < PERPENDICULAR: ("\u22a5" | "\u27c2") >
  | < EQUAL:    ("=" | "%=") > // %= for Giac
  | < PLUS:  "+"  >
  | < MINUS:    ("-"  | "\u2013" | "\u2212") >
  | < PLUSMINUS:    ("\u00b1") >
  | < SUPERSCRIPT_MINUS: "\u207b" >
  | < POWER:    ("^" | "**" | "\u02C6") >
    // dot operators for multiplication sign
  | < MULTIPLY: ("*" | "\u22c5" | "\u2219" | "\u00D7") >
  | < TILDE: "~" >
  | < VECTORPRODUCT: "\u2297" >
  | < DIVIDE:   ("/" | "\u00f7") >
  | < INVISIBLE_PLUS: "\u2064" >
  | < FACTORIAL: "!" >
  | < UNDEFINED: ( "?" | "\ufffd" | "Undefined" | "NaN" ) >
//  | < POWER0:   "\u2070" >
//  | < POWER1:   "\u00b9" >
//  | < SQUARED:  "\u00b2" >
//  | < CUBED:    "\u00b3" >
//  | < POWER4:   "\u2074" >
//  | < POWER5:   "\u2075" >
//  | < POWER6:   "\u2076" >
//  | < POWER7:   "\u2077" >
//  | < POWER8:   "\u2078" >
//  | < POWER9:   "\u2079" >
  | < POWERN: (<SUPERSCRIPT_MINUS>)? ( <INDEXDIGIT> )+ >
  | < #INDEXDIGIT:                                     // unicode digits
       [ "\u2070","\u2074"-"\u2079","\u00b9","\u00b2","\u00b3"] >
  | < PI:       ( "pi" | "Pi" | "\u03c0" ) >
  | < EULER_GAMMA:       ( "euler_gamma" | "\u212F_\u03B3" ) > // Euler�Mascheroni constant
  | < E:        ("\u212f") > // Euler constant
  | < IMAGINARY: ("\u03af") > // imaginary constant
  // 02da is "Ring Above", Alt-k in iPad
  // 00ba is Masculine ordinal indicator Alt-zero on OSX
  | < DEGREE_SYMBOL:   ( "\u00b0" | "\u02da" | "\u00ba") >
  | < DEGREE_WORD:   ("deg") >
  | < GRADIAN:   ( "\u1D4D") > // superscript g
  | < ANGLE_MINUTES:   ( "\u2032" ) >
  | < ANGLE_SECONDS:   ( "\u2033" | "\u2032\u2032" | "''") >
  | < INFINITY: ("\u221e" | "Infinity" | "inf" | "infinity") >
  | < RAD:      "rad" >
  | < DERIVATIVE: "'" >
  | < TRUE:     ( "true" | "True" ) >
  | < FALSE:    ( "false" | "False" ) >
  | < #OVERLINE: "\u0305" >
  | < DECIMAL_POINT:    ( "." | "\u066b" ) > // Arabic decimal point
  | < COMMA:    ( "," | "\u060c" | "\u23B8" ) > // Arabic comma, vertical bar for Austrian points
}

TOKEN : {
      < VARX: "x" >
  |    < VARY: "y" >
  |    < VARZ: "z" >
  //|     < PARAMETRICVAR: (("\u0058") /*| ( ("(") (< VARX >) (< COMMA >) (< VARY >) (")"))*/) > // X
  |     < FLOAT:  (<INTEGER> | <DECIMAL_POINT>)+ > //deliberately trap eg 1.2.3.4 , 1..2 here, error then thrown in MyDouble.parseDouble()
  |     < EFLOAT: <FLOAT> ("E") (<PLUS> | <MINUS>)? <INTEGER> >
  |     < RECURRING_DIGITS: <OVERLINE> (<DIGIT> <OVERLINE>)* >
  |     < INTEGER: <GINTEGER> >
}

TOKEN : {
   // labels for cells in the spreadsheet
   <SPREADSHEET_LABEL: ("$")?(["A"-"Z"]|["a"-"z"])+("$")?(["0"-"9"])+ > // e.g. B12
 |
   // standard case: labels for GeoElements and command names
   < LABEL: <GLABEL> >
 | < GSSLABEL: "@"<GLABEL> >

}



// labels for function names
TOKEN : {
    < X_FUNC:  ("x" | "xcoord")  ("("|"[")>
|  < Y_FUNC:  ("y" | "ycoord")   ("("|"[")>
|  < Z_FUNC:  ("z" | "zcoord")   ("("|"[")>
|  < RANDOM_FUNC:  "random()"  >
|    < SQRT_SHORT: "\u221a" >
|   < FUNCTION_LABEL: (<SPREADSHEET_LABEL> | <LABEL> ) ("("|"[") >
|   < FUNCTION_POWER_LABEL: (<SPREADSHEET_LABEL> | <LABEL> ) (< POWERN > )("("|"[") >
|   < LBRACE: "{" >
}

<*> TOKEN : {
   < RBRACE: "}" >
|   < POLAR_SEPARATOR: ( "\u2221" | ";" ) > // separator used by Giac instead of ;
|   < GPAD_MACRO: "@@macro" >
|   < GPAD_RETURN: "@@return" >
}

<DEFAULT, GK_STR_BLOCK, GK_animation_BLOCK, GK_EXPR_BLOCK> TOKEN : {
 < TEXT: "\""  (<CHAR>)* "\"" >
}

<GK_BLOCK> TOKEN : {
 < GK_animation: "animation" > |
 < GK_allowReflexAngle: "allowReflexAngle" > |
 < GK_boundingBox: "boundingBox" > |
 < GK_barTag: "barTag" > |
 < GK_casMap: "casMap" > |
 < GK_checkbox: "checkbox" > |
 < GK_coefficients: "coefficients" > |
 < GK_contentSize: "contentSize" > |
 < GK_coords: "coords" > |
 < GK_cropBox: "cropBox" > |
 < GK_dimensions: "dimensions" > |
 < GK_eigenvectors: "eigenvectors" > |
 < GK_embed: "embed" > |
 < GK_embedSettings: "embedSettings" > |
 < GK_eqnStyle: "eqnStyle" > |
 < GK_font: "font" > |
 < GK_forceReflexAngle: "forceReflexAngle" > |
 < GK_lineStyle: "lineStyle" > |
 < GK_listener: "listener" > |
 < GK_listType: "listType" > |
 < GK_matrix: "matrix" > |
 < GK_objColor: "objColor" > |
 < GK_parent: "parent" > |
 < GK_show: "show" > |
 < GK_slider: "slider" > |
 < GK_spreadsheetTrace: "spreadsheetTrace" > |
 < GK_startPoint: "startPoint" > |
 < GK_strokeCoords: "strokeCoords" > |
 < GK_tableview: "tableview" > |
 < GK_tag: "tag" > |
 < GK_tempUserInput: "tempUserInput" > |
 < GK_value: "value" > |
 < GK_variables: "variables" > |
 < GK_BOOL: "autocolor" |
    "auxiliary" |
    "breakpoint" |
    "centered" |
    "comboBox" |
    "contentSerif" |
    "fixed" |
    "hideLabelInAlgebra" |
    "inBackground" |
    "interpolate" |
    "isLaTeX" |
    "isMask" |
    "keepTypeOnTransform" |
    "levelOfDetailQuality" |
    "outlyingIntersections" |
    "random" |
    "selectionAllowed" |
    "showGeneralAngle" |
    "showOnAxis" |
    "showTrimmed" |
    "symbolic" |
    "trace" |
    "userinput"> |
 < GK_INT: "arcSize" |
    "decimals" |
    "layer" |
    "length" |
    "selectedIndex" |
    "significantfigures" |
    "slopeTriangleSize" > |
 < GK_FLOAT: "fading" |
    "ordering" |
    "pointSize" > |
 < GK_STR: "angleStyle" |
    "audio" |
    "caption" |
    "content" |
    "coordStyle" |
    "curveParam" |
    "decoration" |
    "dynamicCaption" |
    "endStyle" |
    "filename" |
    "headStyle" |
    "incrementY" |
    "javascript" |
    "labelMode" |
    "linkedGeo" |
    "parentLabel" |
    "pointStyle" |
    "showIf" |
    "startStyle" |
    "textAlign" |
    "tooltipMode" |
    "verticalAlign" |
    "video" > |
 < GK_XYCOORDS: "@screen" | "labelOffset" > |
 < GK_RGBA: "bgColor" | "borderColor" > |
 < GK_DELETE: "~"((["A"-"Z"]|["a"-"z"]|"@")+) > |
 < GK_COLON: ":" >
}

<GK_animation_BLOCK> TOKEN : {
 < GK_animation_play: "play" > |
 < GK_animation_tilde_play: "~play" > |
 < GK_animation_plus: "+" > |
 < GK_animation_minus: "-" > |
 < GK_animation_equal: "=" > |
 < GK_animation_speed: "speed" > |
 < GK_number: (["0"-"9"])+("." (["0"-"9"])+)? >
}

<GK_EXPR_BLOCK> TOKEN : {
 < GK_objColor_rgb: "rgb" > |
 < GK_objColor_hsv: "hsv" > |
 < GK_objColor_hsl: "hsl" > |
 < GK_objColor_inverse: "inverse" > |
 < GK_objColor_tilde_inverse: "~inverse" > |
 < GK_startPoint_absolute: "absolute" > |
 < GK_startPoint_tilde_absolute: "~absolute" > |
 < GK_startPoint_pipe: "|" > |
 < GK_EXPR_comma: "," > |
 < GK_EXPR_lparen: "(" > |
 < GK_EXPR_rparen: ")" > |
 < GK_EXPR_plus: "+" > |
 < GK_EXPR_minus: "-" > |
 < GK_EXPR_multiply: "*" > |
 < GK_EXPR_divide: "/" > |
 < GK_EXPR_power: "^" > |
 < GK_objColor_RGBA_HEX_COLOR: <RGBA_HEX_COLOR> > |
 // slider attribute names (must come before GK_EXPR_LABEL to avoid conflicts)
 < GK_slider_min: "min" > |
 < GK_slider_max: "max" > |
 < GK_slider_width: "width" > |
 < GK_slider_x: "x" > |
 < GK_slider_y: "y" > |
 < GK_slider_equal: "=" > |
 // slider boolean flags
 < GK_slider_vertical: "vertical" > |
 < GK_slider_tilde_vertical: "~vertical" > |
 < GK_slider_algebra: "algebra" > |
 < GK_slider_tilde_algebra: "~algebra" > |
 < GK_slider_constant: "constant" > |
 < GK_slider_tilde_constant: "~constant" > |
 < GK_slider_screen: "@screen" > |
 < GK_slider_tilde_screen: "~@screen" > |
 < GK_slider_fixed: "fixed" > |
 < GK_slider_tilde_fixed: "~fixed" > |
 < GK_tempUserInput_eval: "eval" > |
 < GK_tempUserInput_display: "display" > |
 < GK_EXPR_LABEL: <GLABEL> > |
 < GK_EXPR_FLOAT: <GINTEGER> ("." <GINTEGER>)? > |
 < GK_objColor_fill_equals_value: "fill" ([" ", "\t"])* "=" ([" ", "\t"])* (["a"-"z"])+ > |
 < GK_objColor_angle_equals_value: "angle" ([" ", "\t"])* "=" ([" ", "\t"])* (["0"-"9"])+ > |
 < GK_objColor_dist_equals_value: "dist" ([" ", "\t"])* "=" ([" ", "\t"])* (["0"-"9"])+ > |
 // symbol=xxx where xxx is double quoted string or single printable unicode character
 < GK_objColor_symbol_equals_value: "symbol" ([" ", "\t"])* "=" ([" ", "\t"])* (("\"" (<CHAR>)* "\"") | <PRINTABLE_CHAR>) > |
 // image=xxx where xxx is doubele quoted string or characters excluding some special
 < GK_objColor_image_equals_value: "image" ([" ", "\t"])* "=" ([" ", "\t"])* (("\"" (<CHAR>)* "\"") | (~["\u0000"-"\u001F", ";", "}", " ", "\t", "\u007F", "\""])+) > |
 // bar=xxx where xxx is digits only (required for barTag)
 < GK_barTag_bar_equals_value: "bar" ([" ", "\t"])* "=" ([" ", "\t"])* (["0"-"9"])+ >
}

<GK_STR_BLOCK> TOKEN : {
 < GK_STR_UNQUOTED: (~["\"", ";", "}", " ", "\t", "\r", "\n"]) >
}

<GK_VALUE_BLOCK> TOKEN : {
 < GK_RGBA_HEX_COLOR: <RGBA_HEX_COLOR> > |
 < GK_lineStyle_thickness: "thickness" > |
 < GK_lineStyle_hidden: "hidden" > |
 < GK_lineStyle_opacity: "opacity" > |
 < GK_lineStyle_arrow: "arrow" > |
 < GK_lineStyle_tilde_arrow: "~arrow" > |
 < GK_lineStyle_type_pointwise: "pointwise" > |
 < GK_lineStyle_type_full: "full" > |
 < GK_lineStyle_type_dashedshort: "dashedshort" > |
 < GK_lineStyle_type_dashedlong: "dashedlong" > |
 < GK_lineStyle_type_dotted: "dotted" > |
 < GK_lineStyle_type_dasheddotted: "dasheddotted" > |
 < GK_lineStyle_dashed: "dashed" > |
 < GK_lineStyle_show: "show" > |
 < GK_cropBox_x: "x" > |
 < GK_cropBox_y: "y" > |
 < GK_cropBox_cropped: "cropped" > |
 < GK_cropBox_tilde_cropped: "~cropped" > |
 < GK_dimensions_angle: "angle" > |
 < GK_dimensions_scaled: "scaled" > |
 < GK_dimensions_tilde_scaled: "~scaled" > |
 < GK_font_serif: "serif" > |
 < GK_font_tilde_serif: "~serif" > |
 < GK_font_plain: "plain" > |
 < GK_font_bold: "bold" > |
 < GK_font_italic: "italic" > |
 < GK_show_object: "object" > |
 < GK_show_tilde_object: "~object" > |
 < GK_show_ev1: "ev1" > |
 < GK_show_tilde_ev1: "~ev1" > |
 < GK_show_ev2: "ev2" > |
 < GK_show_tilde_ev2: "~ev2" > |
 < GK_show_3d: "3d" > |
 < GK_show_tilde_3d: "~3d" > |
 < GK_show_plane: "plane" > |
 < GK_show_tilde_plane: "~plane" > |
 // tableview boolean flags
 < GK_tableview_points: "points" > |
 < GK_tableview_tilde_points: "~points" > |
 // spreadsheetTrace boolean flags
 < GK_spreadsheetTrace_trace: "trace" > |
 < GK_spreadsheetTrace_tilde_trace: "~trace" > |
 < GK_spreadsheetTrace_column: "column" > |
 < GK_spreadsheetTrace_row: "row" > |
 < GK_spreadsheetTrace_reset: "reset" > |
 < GK_spreadsheetTrace_tilde_reset: "~reset" > |
 < GK_spreadsheetTrace_list: "list" > |
 < GK_spreadsheetTrace_tilde_list: "~list" > |
 < GK_spreadsheetTrace_copy: "copy" > |
 < GK_spreadsheetTrace_tilde_copy: "~copy" > |
 < GK_spreadsheetTrace_pause: "pause" > |
 < GK_spreadsheetTrace_tilde_pause: "~pause" > |
 < GK_VALUE_label: "label" > |
 < GK_VALUE_tilde_label: "~label" > |
 < GK_VALUE_width: "width" > |
 < GK_VALUE_height: "height" > |
 < GK_VALUE_equal: "=" > |
 < GK_VALUE_star: "*" > |
 < GK_VALUE_slash: "/" > |
 < GK_coords_v: "v" > |
 < GK_coords_w: "w" > |
 < GK_VALUE_float: ("-")? (["0"-"9"])+("." (["0"-"9"])+)? >
}

<GK_BLOCK, GK_animation_BLOCK, GK_STR_BLOCK, GK_VALUE_BLOCK, GK_EXPR_BLOCK> TOKEN : {
 < GK_INVALID: (~[";", "}"]) >
}

/**
 * for GeoGebra input field
 * validexpression =
 *                  labellist() = functionOrCommand() |           // e.g. {A,B} = Intersect[c, g]
 *                      &lt;LABEL&gt; : parametric() |        // e.g. X = (3,2) + t (2,1)
 *                      &lt;LABEL&gt; = expression()      // arithmetic expression of floats, vectors and vars
 *                      &lt;LABEL&gt; : equation()        // equation in x an y
             &lt;LABEL&gt;(x) = function()   // function in x, e.g. f(x) = 3x^3 - sqrt(x)
 */
ValidExpression buildValidExpression() :
{
    ValidExpression ve = null;
    ExpressionNode conditions = null;
    Token l = new Token();
}
{
     (
        // f(x) =  x^2 + 3
        LOOKAHEAD(2147483647)
        ve = functionExpressionnode()
        {
			if (ve.unwrap() instanceof Equation) {
				ve = ((Equation) ve.unwrap()).equationOrAssignment();
			}
		}
     |
       // spreadsheet range like A1:B2
    LOOKAHEAD (3)
    ve = spreadsheetRange()
     |
        // special case "A: (3,2)" should become a point
        // CAS assignment "a := 5" should be supported too
        // inequalities "a: 3x + 4y < 7" and intervals "b: 3 < x < 7" can be named too
      LOOKAHEAD(2147483647)
      l = label() (":" | <ASSIGNMENT> )  ve = expressionOrEquation()
      {
            if (GParser.shouldSplitLabel(l.image)) {
                ve = new Equation(kernel, new Variable(kernel, l.image), ve).equationOrAssignment();
            }
      }
   |
        LOOKAHEAD(2147483647)
        (
          (ve = expressionOrEquation())
        {
          if (ve instanceof Equation)
          {
            ve = ((Equation)ve).equationOrAssignment();
          }
        })
        (conditions = conditions()
        {
            ve = new ExpressionNode(kernel, conditions, Operation.IF_SHORT, ve);
        })?

		| LOOKAHEAD(2147483647) ve = vectorSpecial()
    )
    ( <POLAR_SEPARATOR> | <EOF> )
    {
        if (ve.labelCount() == 0)
        {
          ve.addLabel(l.image);  // standard case
        }
        return ve;
    }
}

/**
 *  parse GeoGebra CAS input
 */
ValidExpression buildCASExpression(GeoSymbolicI cell) :
{
    ValidExpression ve;
    Token l = new Token();
    Token assign = null;
}
{
        // CAS function
       // f(a) := a^2 + 3a
     (
        LOOKAHEAD(2147483647)
        ve = casFunction(cell)
    |
         // labeled equation, e.g. g: 3x + y = 7
         // assignment
        // b := 27 + c, also allow x := 5, see TRAC-864
        LOOKAHEAD(2147483647)
    l = casVar() (assign= ":" |assign = <ASSIGNMENT> | assign = <DELAYED_ASSIGNMENT > ) ve = expressionOrEquation()
   |
         // equation, e.g. 3x + y = 7
         LOOKAHEAD(2147483647)
         ve = expressionOrEquation()
  )
    ( <POLAR_SEPARATOR> | <EOF> )
    {
      // remember label
      if (l.image != null)
      {
          if (":".equals(assign.image) &&
          GeoElementSpreadsheet.isSpreadsheetLabel(ve.toString(StringTemplate.defaultTemplate)))
          {
            ExpressionNode startCell = new ExpressionNode(kernel, new Variable(kernel, l.image));
    ExpressionNode endCell = new ExpressionNode(kernel, new Variable(kernel, ve.toString(StringTemplate.defaultTemplate)));
    Command cmd = new Command(kernel, "CellRange", false, !externalCASParsing ); // don't translate name
    cmd.addArgument(startCell);
    cmd.addArgument(endCell);
    return cmd;
          }
          ve.addLabel(l.image);
          if (cell != null) {
              cell.setAssignmentType(assign.kind == DELAYED_ASSIGNMENT?AssignmentType.DELAYED:AssignmentType.DEFAULT);
          }
       }
        return ve;
    }
}


/**
 * convert Giac String to GeoGebra string
 */
private ValidExpression buildGiacExpression() :
{
    ValidExpression ve;
}
{
    (
    // try to parse Giac string as standard GeoGebra expression
      ve = buildCASExpression(null)
  )
    ( <POLAR_SEPARATOR> | <EOF> )
    {
        return ve;
    }
}

/**
 * (&lt;VARZ&gt; | &lt;LABEL&gt; | &lt;SPREADSHEET_LABEL&gt;)
 */
Token label():
{
    Token t;
}
{
       ( t = <VARZ> | t = <SPREADSHEET_LABEL> |  t = <LABEL> )
        {  return t;   }
}

/**
 * (&lt;VARX&gt; | &lt;VARY&gt; | &lt;VARZ&gt; | &lt;LABEL&gt; | &lt;SPREADSHEET_LABEL&gt;)
 */
Token casVar():
{
  Token t;
}
{
  (t = <VARX> | t = <VARY> | t = <VARZ> | t = <LABEL> | t = <SPREADSHEET_LABEL>)
  {
    return t;
  }
}


/******************************************************************
 * ARITHMETIC FOR NUMBERS AND 2D VECTORS WITH VARIABLES
 * plus
 * ARITHMETIC FOR POLYNOMIALS WITH VARIABLES "x" AND "y"
 * exponents must be integers >= 0
 * divisors must be simplifyable to numbers
 ******************************************************************/

/**
 * function = functionExpressionnode
 */
Function  function():
{
    ExpressionNode rhs;
    Function f;
}
{
(
     // f(x) =  x^2 + 3
      rhs = functionExpressionnode()
      {
        if (rhs.getLeft() instanceof Function) {
          f = (Function) rhs.getLeft();
        }
        else {
            f = new Function(kernel, rhs);
        }
        f.setLabel(rhs.getLabel());
        return f;
      }
)
}

/**
 * functionNVar = functionExpressionnode
 */
FunctionNVar  functionNVar():
{
    ExpressionNode rhs;
    FunctionNVar f;
}
{
(
     // f(x) =  x^2 + 3
      rhs = functionExpressionnode()
      {
        if (rhs.getLeft() instanceof FunctionNVar) {
          f = (FunctionNVar) rhs.getLeft();
        }
        else {
            f = new FunctionNVar(kernel, rhs);
        }
        f.setLabel(rhs.getLabel());
        return f;
      }
)
}

ExpressionNode conditions():
{

    ExpressionNode condition = null;
    ExpressionNode conditions = null;
}
{

(
  <COMMA> (condition = expressionnode())
          {
            conditions = conditions == null ? condition : new ExpressionNode(kernel, conditions, Operation.AND, condition);
          })+
          {
            return conditions;
          }
}
/**
 * function =   f(var1, var2) = expressionnode
 *        f(var) := expressionnode
 *        f(var) = command
 */
ExpressionNode functionExpressionnode():
{
    ExpressionNode rhs;
    ExpressionNode cond = null;
    Token funName = null;
    Token varName = null;
    Token assignmentOp = null;
    ArrayList<String> localVars;
}
{
(
      // single or multi-variable function definition
     // f(a) =  a^2 + 3
     // g(x,y) := x * y
     (
       funName = <FUNCTION_LABEL> |  // includes "(" at end
       funName = <Z_FUNC> // includes "(" at end
     )
         // local variables, allow function of y and deal with it in GeoFunction constructor
         (( varName =  <VARX> | varName =  <VARY> | varName = label() )
           { localVars = new ArrayList<String>(); localVars.add(varName.image);
           kernel.getConstruction().registerFunctionVariable(varName.image);} )
      // optional second variable
       (<COMMA> ( varName = casVar() )
        {
            localVars.add(varName.image);
            kernel.getConstruction().registerFunctionVariable(varName.image);
        } )*
      // closing ) and assignment with expressionnode
          ")" ( <EQUAL > | assignmentOp = <ASSIGNMENT> ) rhs = expressionnode() (cond = conditions())?
        {
            String funLabel = funName.image.substring(0, funName.image.length() - 1);
            return functionParser.assignment(rhs, funLabel, localVars, cond, assignmentOp != null);
        }
)
}

/**
 * CAS function =   label(var) := expressionnode
 */
FunctionNVar casFunction(GeoSymbolicI cell):
{
    ExpressionNode rhs,cond = null;
    Token funName;
    Token varName;
    Token assign;
    ArrayList<String> localVars;
}
{
(
      // single or multi-variable function definition
     // f(a) =  a^2 + 3
     // g(x,y) := x * y
     (
       funName = <FUNCTION_LABEL> |  // includes "(" at end
       funName = <Z_FUNC> // includes "(" at end
     )
         // local variables
         (( varName =  casVar() )
           { localVars = new ArrayList<String>(); localVars.add(varName.image); } )
      // optional second variable
       (<COMMA> ( varName =  casVar() )
       { localVars.add(varName.image); } )*
      // closing ) and assignment with expressionnode
          ")" (assign = <ASSIGNMENT> | assign = < DELAYED_ASSIGNMENT >) rhs = expressionnode() (cond = conditions())?
      {
        if (cond != null)
          {
            rhs = new ExpressionNode(kernel, cond, Operation.IF_SHORT, rhs);
          }
        String funLabel = funName.image.substring(0,funName.image.length()-1);

      // number of vars
      int n = localVars.size();

      FunctionVariable[] funVar = new FunctionVariable[n];
        for (int i=0; i < n; i++) {
          funVar[i] = new FunctionVariable(kernel, localVars.get(i));
        }

          switch (n) {
            case 1: // single variable function
        Function fun = new Function(rhs, funVar[0]);
        fun.setLabel(funLabel);
        if (cell != null) {
              cell.setAssignmentType(assign.kind == DELAYED_ASSIGNMENT?AssignmentType.DELAYED:AssignmentType.DEFAULT);
        }
        return fun;

             default: // multi variable function
             FunctionNVar funn = new FunctionNVar(rhs, funVar);
        funn.setLabel(funLabel);
        if (cell != null) {
              cell.setAssignmentType(assign.kind == DELAYED_ASSIGNMENT?AssignmentType.DELAYED:AssignmentType.DEFAULT);
        }
        return funn;
          }
      }
)
}


/**
 *  expression =  term &lt;IMPLIES&gt; term
 */
ExpressionNode expressionnode():
{
    ExpressionValue ret, f;
}
{
    ret = ORterm()
    ( <IMPLICATION>  f = ORterm()
        {
           ret = new ExpressionNode(kernel, ret, Operation.IMPLICATION, f);
        }
    )*
    {
      ExpressionNode en;
      if (ret.isExpressionNode())
        en = (ExpressionNode) ret;
      else
        en = new ExpressionNode(kernel, ret);

      //en.expandEquationExpressions();
      if (externalCASParsing) {
        en.simplifyLeaves();
      }
      return en;
    }
}

/**
 *  expressionOrEquation =  equation | expressionnode
 */
ValidExpression expressionOrEquation():
{
      ExpressionNode en;
    ExpressionNode rhs = null;
    ExpressionNode rrhs = null;
}
{
     en = expressionnode()
      (  <EQUAL> rhs = expressionnode()
        (  <EQUAL> rrhs = expressionnode()

          )?
      )?
  {
    if (rrhs!=null)
    {
      return new MyVecNode(kernel, new Equation(kernel, en, rhs), new Equation(kernel, en, rrhs)).wrap();
    }

    return  rhs == null ? en : new Equation(kernel, en, rhs);
  }
}

/**
 * ANDterm =   COMPAREterm &lt;AND&gt; COMPAREterm
 */
ExpressionValue ANDterm():
{
    ExpressionValue ret, f;
}
{
    ret = COMPAREterm()
    ( <AND>  f = COMPAREterm()
        {
          ret = new ExpressionNode(kernel, ret, Operation.AND, f);
        }
    )*
    { return ret; }
}

/**
 * XORterm =   ANDterm &lt;XOR&gt; ANDterm
 */
ExpressionValue XORterm():
{
    ExpressionValue ret, f;
}
{
    ret = ANDterm()
    ( <XOR>  f = ANDterm()
        {
          ret = new ExpressionNode(kernel, ret, Operation.XOR, f);
        }
    )*
    { return ret; }
}

/**
 * ORterm =   XORterm &lt;OR&gt; XORterm
 */
ExpressionValue ORterm():
{
    ExpressionValue ret, f;
}
{
    ret = XORterm()
    ( <OR>  f = XORterm()
        {
          ret = new ExpressionNode(kernel, ret, Operation.OR, f);
        }
    )*
    { return ret; }
}

/**
 * COMPAREterm =   listopnode ("==" | "&lt;" | "&lt;=" | "&gt;" | "&gt;=") listopnode
 */
ExpressionValue COMPAREterm():
{
    ExpressionValue left, right;
    ExpressionNode result;
    Vector<ExpressionNode> andList = null; // support multiple comparisons like 3 < x < 7
}
{
    left = listopnode()
    (
       (
         (<EQUAL_BOOLEAN>  right = listopnode()
       {
         if (externalCASParsing)
             result = new ExpressionNode(kernel, new Equation(kernel, left, right));
         else
                result = new ExpressionNode(kernel, left, Operation.EQUAL_BOOLEAN, right);
         }
       )
     |
       (<NOT_EQUAL>  right = listopnode()
       {
           result = new ExpressionNode(kernel, left, Operation.NOT_EQUAL, right);
         }
       )
     |
       (<IS_SUBSET_OF>  right = listopnode()
       {
           result = new ExpressionNode(kernel, left, Operation.IS_SUBSET_OF, right);
         }
       )
     |
       (<IS_SUBSET_OF_STRICT>  right = listopnode()
       {
           result = new ExpressionNode(kernel, left, Operation.IS_SUBSET_OF_STRICT, right);
         }
       )
     |
       (<LESS>  right = listopnode()
       {
           result = new ExpressionNode(kernel, left, Operation.LESS, right);
         }
       )
     |
       (<GREATER>  right = listopnode()
       {
           result = new ExpressionNode(kernel, left, Operation.GREATER, right);
         }
       )
     |
       (<LESS_EQUAL>  right = listopnode()
       {
           result = new ExpressionNode(kernel, left, Operation.LESS_EQUAL, right);
         }
       )
     |
       (<GREATER_EQUAL>  right = listopnode()
       {
           result = new ExpressionNode(kernel, left, Operation.GREATER_EQUAL, right);
         }
       )
      |
         (<PARALLEL>  right = listopnode()
       {
           result = new ExpressionNode(kernel, left, Operation.PARALLEL, right);
         }
         )
      |
         (<PERPENDICULAR>  right = listopnode()
       {
           result = new ExpressionNode(kernel, left, Operation.PERPENDICULAR, right);
         }
        )
     )
     {
        // store all AND parts
        // e.g. 3 < x < 7 should get stored as 3 < x && x < 7
        if (andList == null)
      andList = new Vector<ExpressionNode>();
    andList.add(result);
    left = right;
     }
    )*
    {
      if (andList != null) {
      // build AND ExpressionNode tree, e.g. 3 < x && x < 7
        left = andList.get(0);
        for (int i=1; i < andList.size(); i++) {
      left = new ExpressionNode(kernel, left, Operation.AND_INTERVAL, andList.get(i));
        }
      }
      return left;
    }
}

/**
 *  expression =    term + term |
 *                  term - term
 */
ExpressionValue plusminusnode():
{
    ExpressionValue ret, f;
    Token x;
}
{
    ret = multterm()
    (( x = <PLUS> | x = <MINUS> | x = <PLUSMINUS> ) f = multterm()
        {
            if (x.kind == PLUS) {
				ret = new ExpressionNode(kernel, ret, Operation.PLUS, f);
            } else if (x.kind == PLUSMINUS) {
                ret = new ExpressionNode(kernel, ret, Operation.PLUSMINUS, f);
            } else {
              if (ret.isExpressionNode() && ((ExpressionNode) ret).isStringAddition()) {
                ((ExpressionNode) ret).setRight(new ExpressionNode(kernel,
                            ((ExpressionNode) ret).getRight(), Operation.MINUS, f));
              } else {
                 ret = new ExpressionNode(kernel, ret, Operation.MINUS, f);
              }
            }
      }
    )*
    {
      return ret;
    }
}

ExpressionValue sequencenode():
{
    ExpressionValue ret, f;
}
{
    ret = plusminusnode()
    (<SEQUENCE_OPERATOR> f = plusminusnode()
        {
            ret = new ExpressionNode(kernel, ret, Operation.SEQUENCE, f);
        }
    )*
    {
      return ret;
    }
}

ExpressionValue setdifferencenode():
{
    ExpressionValue ret, f;
}
{
    ret = sequencenode()
    (<SET_DIFFERENCE> f = sequencenode()
        {
            ret = new ExpressionNode(kernel, ret, Operation.SET_DIFFERENCE, f);
        }
    )*
    {
      return ret;
    }
}

ExpressionValue listopnode():
{
    ExpressionValue ret, f;
}
{
    ret = setdifferencenode()
    (<IS_ELEMENT_OF> f = setdifferencenode()
        {
            ret = new ExpressionNode(kernel, ret, Operation.IS_ELEMENT_OF, f);
        }
    )*
    {
      return ret;
    }
}

/**
 * multterm =   divterm * divterm
 * "a b c" is interpreted as "(a b) c" unless c is the degree symbol
 */
ExpressionValue multterm():
{
    ExpressionValue ret, f;
    Token x;
}
{
    ret = divterm()
    (
     ( x = <MULTIPLY> | x = <VECTORPRODUCT> ) f = divterm()
        {
            if (x.kind == MULTIPLY) {
                ret = new ExpressionNode(kernel, ret, Operation.MULTIPLY, f);
            } else {
                ret = new ExpressionNode(kernel, ret, Operation.VECTORPRODUCT, f);
            }
        }
     |
     // We do not want to accept | here because it may lead to confusing opening and closing abs bars
     LOOKAHEAD( { getToken(1).kind != VERTICAL_BAR} )
     f = powerdivterm()
        {
            ExpressionValue special = functionParser.multiplySpecial(ret, f, giacParsing, geoGebraCASParsing);
            if (special == null) {
                if (ExpressionNode.isConstantDouble(f, Kernel.PI_180)
                        && ret instanceof ExpressionNode
                        && ((ExpressionNode) ret).getOperation() == Operation.MULTIPLY) {
                    ((ExpressionNode) ret).setRight(new ExpressionNode(kernel,
                        ((ExpressionNode) ret).getRight(), Operation.MULTIPLY, f));
                } else {
                    ret = new ExpressionNode(kernel, ret, Operation.MULTIPLY, f);
                }
            } else {
                ret = special;
            }
        }

    )*
    { return ret; }
}

/**
 * divterm =  mixednumberterm / mixednumberterm
 */
ExpressionValue divterm():
{
    ExpressionValue ret, f;
}
{
    ret = mixednumberterm()
    (
       <DIVIDE> f = mixednumberterm()
        {
            ret = new ExpressionNode(kernel, ret, Operation.DIVIDE, f);
        }
    )*
    { return ret; }
}

/**
* mixednumberterm = unary + divterm
*/
ExpressionValue mixednumberterm():
{
	ExpressionValue ret, numerator, denominator = null;
}
{
	ret = enunary()
	(<INVISIBLE_PLUS> numerator = enunary() (LOOKAHEAD(2) <DIVIDE> denominator = enunary())?
		{
			ExpressionValue fraction = denominator == null ? numerator
				: new ExpressionNode(kernel, numerator, Operation.DIVIDE, denominator);
			ret = new ExpressionNode(kernel, ret, Operation.INVISIBLE_PLUS, fraction);
		}
	)*
	{ return ret; }
}

/**
 * powerdivterm =  power / unary
 */
ExpressionValue powerdivterm():
{
    ExpressionValue ret, f;
}
{
    ret = enpower()
    (
       <DIVIDE> f = enunary()
        {
            ret = new ExpressionNode(kernel, ret, Operation.DIVIDE, f);
        }
    )*
    { return ret; }
}

/**
 * unary =  -power    |
 *           +power    |
 *          power
 */
ExpressionValue enunary():
{
    ExpressionValue e;
    ExpressionValue ret;
	int minusCount = 0;
}
{
   (
    (<MINUS> { minusCount++;} )+ e = enpower()
        { // -e  = -1*e, --e = e
          ret = minusCount % 2 == 0 ? e : ExpressionNode.unaryMinus(kernel, e);
        }
|
   <PLUS> e = enpower()
        { // +e  = e
          ret = e;
        }
        |
   <PLUSMINUS> e = enpower()
        { // +e  = e
          ret = new ExpressionNode(kernel,e,Operation.PLUSMINUS,new MyNumberPair(kernel));
        }
|
    e = enpower()
        {
            ret = e;
        })
{
  return ret;
}
}

/**
 * power =    element                 |
 *          element ^ power
 */
ExpressionValue enpower():
{
    ExpressionValue ret, f;
    Token c = null;
    ArrayList<ExpressionValue> exponentList = null;

}
{
    ret = enfactorial()
    (
        (
       c = <POWERN>
        {
            f = functionParser.convertIndexToNumber(c.image);
            // collect exponents
            if (exponentList == null) {
                exponentList = new ArrayList<ExpressionValue>();
            }
            exponentList.add(f);
        }
     )
    |
      (
          <POWER> (c = <MINUS> | c = <PLUS>)? f = enfactorial()
        {
            // -f  = -1*f
            if (c != null && c.kind == MINUS) {
                f = ExpressionNode.unaryMinus(kernel, f);
                c = null; // make sure we forget minus for next exponent
            }

            // collect exponents
            if (exponentList == null) {
                exponentList = new ArrayList<ExpressionValue>();
            }
            exponentList.add(f);
        }
        )
    )*
    {
        if (exponentList == null) {
            return ret;
        }

        // GeoGebra / Giac etc : right associative: a^b^c = a^(b^c)
        int size = exponentList.size();
        ExpressionValue tempEV = exponentList.get(size-1); // last exponent, e.g. c
        for (int i=size-2; i >= 0; i--) {
            ExpressionValue prevExponent = exponentList.get(i);
            tempEV = makePower(prevExponent,tempEV);
        }
        ret = makePower(ret, tempEV);
        return ret;

    }
}

/**
 * factorial =  &lt;NOTterm&gt; |
 *              &lt;NOTterm&gt; !
 */
ExpressionValue enfactorial():
{
    ExpressionValue en;
}
{
      en = ensqrt()
      (LOOKAHEAD(<FACTORIAL>) <FACTORIAL>
        {
            if (en.isExpressionNode() && ((ExpressionNode)en).getOperation()==Operation.MULTIPLY_OR_FUNCTION
                    && !((ExpressionNode)en).hasBrackets()) {
                en = new ExpressionNode(kernel, ((ExpressionNode)en).getLeft(),
                        Operation.MULTIPLY,
                        new ExpressionNode(kernel, ((ExpressionNode)en).getRight(), Operation.FACTORIAL, null));
            } else {
                en = new ExpressionNode(kernel, en, Operation.FACTORIAL, null);
            }
        }
       )?
       { return en; }
}

ExpressionValue ensqrt():
{
    ExpressionValue en;
}
{
      (<SQRT_SHORT> en = NOTterm()
    {
        if (en.isExpressionNode() && ((ExpressionNode)en).getOperation()==Operation.MULTIPLY_OR_FUNCTION
                && !((ExpressionNode)en).hasBrackets()) {
            en = new ExpressionNode(kernel,
            new ExpressionNode(kernel, ((ExpressionNode)en).getLeft(), Operation.SQRT_SHORT, null),
                    Operation.MULTIPLY, ((ExpressionNode)en).getRight());
        } else {
            en = new ExpressionNode(kernel, en, Operation.SQRT_SHORT, null);
        }
    } | en = NOTterm())
    { return en; }
}

/**
 * NOTterm =  &lt;NOT&gt; &lt;enelement&gt; |
 *                 &lt;enelement&gt;
 */
ExpressionValue NOTterm():
{
    ExpressionValue en;
}
{
  (
    (
      ( <NOT> | "!" ) en = enelement()
       {
              en = new ExpressionNode(kernel, en, Operation.NOT, null);
       }
     )
|
     (
        en = enelement()
     )
   )
   { return en; }
}

/**
 * element =    &lt;variable&gt;      |
 *              &lt;float&gt;         |
 *              ( expression )
 */
ExpressionValue enelement():
{
    ExpressionValue ev;
    Token c;
}
{
// boolean
  (<TRUE>
   { ev = new MyBoolean(kernel, true); }
|
  <FALSE>
    { ev = new MyBoolean(kernel, false); }
|
 // number
    ev = myDouble()
|
    // cos, sin, tan, ...
    LOOKAHEAD(2147483647)
    ev = functionOrCommand()
|
    // number or vector variable
     LOOKAHEAD(2147483647)
    ev = numVecVariable()
|
    //list
    LOOKAHEAD(2147483647)
  ev = list()
|

    // absolute value
    LOOKAHEAD(2147483647)
    <VERTICAL_BAR> ev = expressionnode() <VERTICAL_BAR>
        {
            ev = new ExpressionNode(kernel, ev, Operation.ABS, null);
        }
|
    // cartesian vector  (x, y) or (x|y)
    LOOKAHEAD(2147483647)
    ev = tuple()
 |

  // text (between " ... ")
  c = <TEXT>
    {
      // remove " (first and last character)
      String text = c.image.substring(1, c.image.length()-1);
      ev = new MyStringBuffer(kernel, text);
     }
   )
   {return ev;}
}

ExpressionValue list():
{
    MyList myList;
    ExpressionValue ev;
}
{
   "{"
 (
   (
     // empty list
       "}"
      {
           myList = new MyList(kernel);
       }
    )
    |
   (
    // list
      ev = expressionOrEquation()
       {
            myList = new MyList(kernel);
            myList.addListElement(ev);
        }
       ( <COMMA> ev = expressionOrEquation()
          {
           myList.addListElement(ev);
          }
        )*
    "}"
   )
 )
    {  return myList;  }
}

ExpressionValue numVecVariable():
{
    Token c;
    ExpressionValue ev = null;
}
{
    (c = <VARX>
    {
        if (geoGebraCASParsing) {
            ev = new Variable(kernel, c.image);
        } else {
            ev = new FunctionVariable(kernel, c.image);
        }
    }
|
    c = <VARY>
    {
        if (geoGebraCASParsing) {
            ev = new Variable(kernel, c.image);
        } else {
            ev = new FunctionVariable(kernel, c.image);
        }
    }
|
    c = <VARZ>
    {
        // check for CAS parsing or if z is defined in kernel
        if (geoGebraCASParsing || kernel.lookupLabel("z") != null) {
            ev = new Variable(kernel, c.image);
        } else {
            // z is not defined: treat as equation variable for 3D view
            ev = new FunctionVariable(kernel, c.image);
        }
    }
|
  // spreadsheet range like A1:B2
  LOOKAHEAD (3)
  ev = spreadsheetRange()
|
    ( c = <SPREADSHEET_LABEL> | c = <LABEL> )
    {
        // should we read e for Euler constant and i for imaginary unit?
        boolean lookforEulerImaginary = false;

        if (geoGebraCASParsing) {
            // leave e and i untouched in GeoGebraCAS view
            lookforEulerImaginary = false;
        }
        else if (externalCASParsing) {
            // Giac does not need it either, may need changing for other CASes
            lookforEulerImaginary = false;
        } else { // GeoGebraCAS or GeoGebra parsing
            // only treat e or i specially when they are undefined in GeoGebra
            lookforEulerImaginary = true;
        }

        // return defined variables immediately
        if (lookforEulerImaginary) {
            // TREAT e and i specially
            // e for Euler constant
            if (c.image.equals("e") && kernel.lookupLabel(c.image) == null
            		&& !kernel.getConstruction().isRegisteredFunctionVariable("e")) {
                ev = kernel.getEulerNumber();
            }
            // i for imaginary unit
            else if (c.image.equals("i") && kernel.lookupLabel(c.image) == null
            					&& !kernel.getConstruction().isRegisteredFunctionVariable("i")) {
                ev = kernel.getImaginaryUnit();
            }
        }
        if (ev == null) { // standard case for variables
            ev = new Variable(kernel, c.image);
        }
    })
    { return ev; }
}


/**
 * spreadsheet range, e.g. A3:B5
 */
Command spreadsheetRange():
{
    Token c, c2;
}
{
  // spreadsheet range like A1:B2
  c = <SPREADSHEET_LABEL> ":" c2 = <SPREADSHEET_LABEL>
  {
    // build command CellRange[ startCell, endCell ]
    ExpressionNode startCell = new ExpressionNode(kernel, new Variable(kernel, c.image));
    ExpressionNode endCell = new ExpressionNode(kernel, new Variable(kernel, c2.image));
    Command cmd = new Command(kernel, "CellRange", false, !externalCASParsing ); // don't translate name
    cmd.addArgument(startCell);
    cmd.addArgument(endCell);
    return cmd;
  }
}

/**
 * floating point number: angle or numeric are distinguished
 */
ExpressionValue myDouble():
{
    Token c;
    Token c2 = null;
    Token s = null;
    Token percent = null;
    Token degree = null;
    Token minutes = null;
    Token seconds = null;
    Token recurringDigits = null;
    MyDouble d;
    ExpressionValue ret = null;
}
{
   (LOOKAHEAD(2)(
     (c = <FLOAT> | c = <EFLOAT> )
     ((percent ="%")
     | LOOKAHEAD(3)((degree = <DEGREE_SYMBOL>)
       (c2 = <FLOAT>)
        (LOOKAHEAD(3)(minutes = <ANGLE_MINUTES> | minutes = "'")(s = <FLOAT>)(<ANGLE_SECONDS>)
         |(minutes = <ANGLE_MINUTES> | minutes = "'")
         |(<ANGLE_SECONDS>)
        )
       )
     | (degree = <DEGREE_SYMBOL>)
     | LOOKAHEAD(3)(minutes = <ANGLE_MINUTES> | minutes = "'")(s = <FLOAT>)(<ANGLE_SECONDS>)
     | (minutes = <ANGLE_MINUTES> | minutes = "'")
     | (seconds = <ANGLE_SECONDS>)
     | (recurringDigits = <RECURRING_DIGITS> )
     )
    )
  {
        String image = c.image.replaceFirst("e", "E");
        boolean isAngle = false;
        boolean hasDegrees = false, hasMinutes = false, hasSeconds = false;
        double vd = 0, vm = 0, vs = 0;
        if (recurringDigits != null) {
            ret = parseRecurringDecimal(c.image.substring(0, c.image.length() - 1),
                        c.image.charAt(c.image.length() - 1) + recurringDigits.image);
        } else if (degree != null) {
            // if e.g. 3deg (no minute no second) we need to do 3*deg for CAS
            if (c2 == null) {
                d = newSpecialDegree();
                return new ExpressionNode(kernel, parseDouble(image, false), Operation.MULTIPLY, d);
            }
             // at least 3deg5' or 3deg5'' (or 3deg5'7'')
            isAngle = true;
            vd = MyDouble.parseDouble(loc, image);
            hasDegrees = true;
            if (minutes != null) {
                vm = parseDouble(c2);
                hasMinutes = true;
                if (s == null) {
                    vs = 0;
                } else {
                    vs = parseDouble(s);
                    hasSeconds = true;
                }
            } else {
                vs = parseDouble(c2);
                hasSeconds = true;
            }
        } else if (minutes != null) {
            isAngle = true;
            vm = MyDouble.parseDouble(loc, image);
            hasMinutes = true;
            if (s == null) {
                vs = 0;
            } else {
                vs = parseDouble(s);
                hasSeconds = true;
            }
        } else if (seconds != null) {
            isAngle = true;
            vs = MyDouble.parseDouble(loc, image);
            hasSeconds = true;
        }
        if (ret == null) {
            if (isAngle) {
                ret = new MyDoubleDegreesMinutesSeconds(kernel, vd, hasDegrees, vm, hasMinutes, vs, hasSeconds);
            } else {
                ret = parseDouble(image, percent != null);
            }
        }
    }
|
    (c = <FLOAT> | c = <EFLOAT> )
    {
		String image = c.image.replaceFirst("e", "E");
		ret = parseDouble(image, false);
    }
|
    (c = <DEGREE_WORD> | c = <DEGREE_SYMBOL>)
    {  // constant for degree to radians
        GeoElement userDefinedDeg = null;
        if (c.image.length() == 3) {
            userDefinedDeg = kernel.lookupLabel(c.image);
        }
        if (userDefinedDeg != null) {
            ret = userDefinedDeg;
        } else {
            ret = newSpecialDegree();
        }
    }
|
    <RAD>
    {  // constant for radians to radians
        GeoElement userDefinedRad = kernel.lookupLabel("rad");
        if (userDefinedRad != null)    {
            ret = userDefinedRad;
        } else {
            d = new MySpecialDouble(kernel, 1.0d, "rad");
            d.setAngle();
            ret = d;
        }
    }
|
    <GRADIAN>
    {  // constant for gradians to radians
        d = new MySpecialDouble(kernel, Math.PI / 200.0d, "\u1D4D");
        d.setAngle();
        ret = d;
    }
|
    <PI>
    {
         ret = new MySpecialDouble(kernel, Math.PI, Unicode.PI_STRING);
    }
|
    <EULER_GAMMA>
    {    
         ret = new MySpecialDouble(kernel, MyDouble.EULER_GAMMA, Unicode.EULER_GAMMA_STRING);
    }
|
    <E>
    {
      ret = kernel.getEulerNumber();
    }
|
   <IMAGINARY>
    {
      ret = kernel.getImaginaryUnit();
    }
 |
    <INFINITY>
    {
        ret = new MyDouble(kernel, Double.POSITIVE_INFINITY);
    }
|
  <UNDEFINED>
  {
        ret = new MyDouble(kernel, Double.NaN);
    })
    {return ret;}
}


/**
 * mathematical Function (cos, sin, tan, ...)
 * or command (Midpoint, Line, ...)
 */
ExpressionNode functionOrCommand():
{
    ValidExpression en;
    MyList myList;
    Token c, closing;
    ExpressionNode ret;
}
{
    (c = <X_FUNC> en = expressionOrEquation() (")"|"]")
    {
        if (geoGebraCASParsing) {
            ret = Command.xyzCAS(en, 0,!externalCASParsing, undecided, kernel);
        } else {
            // standard GeoGebra input bar: x(...) is interpreted as "x-coordinate of"
            ret = new ExpressionNode(kernel, en, Operation.XCOORD, null);
        }
    }
|
     c = <Y_FUNC> en = expressionOrEquation() (")"|"]")
    {
        if (geoGebraCASParsing) {
            // GeoGebra CAS view: y(...) is interpreted as a function
            ret = Command.xyzCAS(en, 1, !externalCASParsing, undecided, kernel);
        } else {
            // standard GeoGebra input bar: y(...) is interpreted as "y-coordinate of"
            ret = new ExpressionNode(kernel, en, Operation.YCOORD, null);
        }
    }
|
     c = <Z_FUNC> en = expressionOrEquation() (")"|"]")
    {
        if (geoGebraCASParsing) {
            ret = Command.xyzCAS(en, 2, !externalCASParsing, undecided, kernel);
        } else {
            // standard GeoGebra input bar: z(...) is interpreted as user function z or "z-coordinate of"
            GeoElement userFun = kernel.lookupLabel("z");
            if (userFun instanceof Evaluatable) {
                // user defined function z
                ret = new ExpressionNode(kernel, userFun, Operation.FUNCTION, en);
            } else {
                // internal function z
                ret = new ExpressionNode(kernel, en, Operation.ZCOORD, null);
            }
        }
    }
|
      ( c = <FUNCTION_POWER_LABEL> ) en = expressionOrEquation() (")"|"]")
    {
        ret = functionParser.handleTrigPower(c.image, en);
        if (ret.getOperation() == Operation.MULTIPLY_OR_FUNCTION) {
            undecided.add(ret);
        }
    }
|      <RANDOM_FUNC>
    {
        Construction cons = kernel.getConstruction();
        GeoNumeric randNum = new GeoNumeric(cons);
        cons.addRandomGeo(randNum);
        randNum.setValue(app.getRandomNumber());
        ret = new ExpressionNode(kernel, randNum, Operation.RANDOM, null);
    }
|
    c = <FUNCTION_LABEL> {
        myList = new MyList(kernel, true);
        nestedCommands++;
    }
     (en = expressionOrEquation()
        {
            myList.addListElement(en);
        }
        (
            <COMMA> en = expressionOrEquation()
            {
                myList.addListElement(en);
            }
        )*
    )?
    (closing = ")" | closing = "]")
    {
        nestedCommands--;
        boolean topLevel = c.beginColumn == 1
                && (closing.next == null || closing.next.kind == EOF || closing.next.kind == POLAR_SEPARATOR);
        // note: the last character of FUNCTION_LABEL is a "("
        ret = functionParser.makeFunctionNode(c.image, myList, undecided, giacParsing,
            geoGebraCASParsing, topLevel, nestedCommands);
    })
    {return ret;}
}

/**
 *  tuple =  ( expression, expression )
 *  tuple =  ( expression, expression, expression )
 * | and ; can be used instead of ,
 */
ExpressionValue tuple():
{
    ExpressionValue x, y = null, z = null;
    Token sep = null;
}
{
    // cartesian coordinates
    "(" x = expressionOrEquation() (
           (  sep = <COMMA> y = expressionOrEquation() (<COMMA> z = expressionnode())?   )
        |  (  sep = <VERTICAL_BAR> y = expressionOrEquation() (<VERTICAL_BAR> z = expressionnode())? )
        |  (  sep = <POLAR_SEPARATOR> y = expressionOrEquation() (<POLAR_SEPARATOR> z = expressionnode())?  )
        )? ")"
    {

        if (y == null) {
            if (giacParsing) {
                x = x.unwrap();
            }
            if (x instanceof ExpressionNode) {
                ((ExpressionNode)x).setBrackets(true);
            }
            return x;
        } else if (z == null) {
            MyVecNode ret = new MyVecNode(kernel, x, y);
            if (sep.kind == POLAR_SEPARATOR) {
                ret.setPolarCoords(x,y);
            }
            return ifStructuresEnabled(ret);
        } else {
            MyVec3DNode ret = new MyVec3DNode(kernel, x, y, z);
            if (sep.kind == POLAR_SEPARATOR) {
                ret.setSphericalPolarCoords(x, y, z);
            }
            return ifStructuresEnabled(ret);
        }
    }
}

/**
* Expression in the form
*   &lt;LABEL&gt; "(" &lt;value&gt; "|" &lt;value&gt; ")" 				-- austrian style 2d point (cartesian)
*   &lt;LABEL&gt; "(" &lt;value&gt; "|" &lt;value&gt; "|" &lt;value&gt; ")"		-- austrian style 3d point (cartesian)
*   &lt;LABEL&gt; "(" &lt;value&gt; ";" &lt;value&gt; ")" 				-- point with polar coordinates
*   &lt;LABEL&gt; "(" &lt;value&gt; ";" &lt;value&gt; ";" &lt;value&gt; ")" 	-- point with spherical coordinates
*/
ValidExpression vectorSpecial():
{
	Token l, sep;
	ExpressionValue x, y, z = null;
}
{
	// cartesian coordinates
	l = <FUNCTION_LABEL> x = expressionOrEquation() (
			(  sep = <VERTICAL_BAR> y = expressionOrEquation() (<VERTICAL_BAR> z = expressionnode())? )
		|   (  sep = <POLAR_SEPARATOR> y = expressionOrEquation() (<POLAR_SEPARATOR> z = expressionnode())?  )
		) ")"
	{
		if (z == null) {
			MyVecNode ret = new MyVecNode(kernel, x, y);
			if (sep.kind == POLAR_SEPARATOR) {
				ret.setPolarCoords(x, y);
			}
			ExpressionNode en = new ExpressionNode(kernel, ret);
			en.setLabel(l.image.substring(0, l.image.length() - 1));
			return ifStructuresEnabled(en);
		} else {
			MyVec3DNode ret = new MyVec3DNode(kernel, x, y, z);
			if (sep.kind == POLAR_SEPARATOR) {
				ret.setSphericalPolarCoords(x, y, z);
			}
			ExpressionNode en = new ExpressionNode(kernel, ret);
			en.setLabel(l.image.substring(0, l.image.length() - 1));
			return ifStructuresEnabled(en);
		}
	}
}

/**
 * Gpad program = (statement)*
 */
void buildGpadProgram() throws GpadParseException :
{
}
{
    (gpadStatement())* (<EOF>)?
}

void gpadStatement() throws GpadParseException :
{
}
{(
    gpadStatementInMacro() |
    gpadMacroDefinition()
)}

void gpadStatementInMacro() throws GpadParseException :
{
}
{(
    gpadStyleSheetDefinition() |
    gpadCommandExpression()
)}

/**
 * Style sheet definition: @name = { property: value; ... }
 */
void gpadStyleSheetDefinition() :
{
    Token name;
    GpadStyleSheet styleSheet;
}
{
    name = <GSSLABEL> <EQUAL>
    styleSheet = gpadStyleSheetBody(name.image.substring(1))
    { gpadStyleSheets.put(name.image.substring(1), styleSheet); }
}

/**
 * Style sheet body: { property1: value1; ...; }
 */
GpadStyleSheet gpadStyleSheetBody(String name) :
{
    GpadStyleSheet styleSheet = new GpadStyleSheet(name);
}
{
    <LBRACE> { token_source.SwitchTo(GK_BLOCK); }
    [(
        gpadStyleSheetKeyValue(styleSheet)
        (
            <POLAR_SEPARATOR> { token_source.SwitchTo(GK_BLOCK); }
            gpadStyleSheetKeyValue(styleSheet)
        )*
    )]
    <RBRACE> { return styleSheet; }
}

void gpadStyleSheetKeyValue(GpadStyleSheet styleSheet) :
{
}
{
    try {
        (
        gpadStyleSheetPropertyDelete(styleSheet) | // ~key (delete)
        gpadStyleSheetPropertyBoolean(styleSheet) | // Boolean key
        gpadStyleSheetPropertyInt(styleSheet) | // Integer key
        gpadStyleSheetPropertyFloat(styleSheet) | // Float key
        gpadStyleSheetPropertyStr(styleSheet) | // String key
        gpadStyleSheetPropertyXYCoords(styleSheet) | // XYCoords key
        gpadStyleSheetPropertyCoords(styleSheet) | // coords key
        gpadStyleSheetPropertyRGBA(styleSheet) | // rgba key #rrggbbaa
        gpadStyleSheetPropertyAnimation(styleSheet) | // animation key
        gpadStyleSheetPropertyCheckbox(styleSheet) | // checkbox key
        gpadStyleSheetPropertyEqnStyle(styleSheet) | // eqnStyle key
        gpadStyleSheetPropertyLineStyle(styleSheet) | // lineStyle key
        gpadStyleSheetPropertyBoundingBox(styleSheet) | // boundingBox key
        gpadStyleSheetPropertyContentSize(styleSheet) | // contentSize key
        gpadStyleSheetPropertyCropBox(styleSheet) | // cropBox key
        gpadStyleSheetPropertyDimensions(styleSheet) | // dimensions key
        gpadStyleSheetPropertyFont(styleSheet) | // font key
        gpadStyleSheetPropertyShow(styleSheet) | // show key
        gpadStyleSheetPropertyObjColor(styleSheet) | // objColor key
        gpadStyleSheetPropertyBarTag(styleSheet) | // barTag key
        gpadStyleSheetPropertySlider(styleSheet) | // slider key
        gpadStyleSheetPropertyTableView(styleSheet) | // tableview key
        gpadStyleSheetPropertySpreadsheetTrace(styleSheet) | // spreadsheetTrace key
        gpadStyleSheetPropertyStartPoint(styleSheet) | // startPoint key
        gpadStyleSheetPropertyTempUserInput(styleSheet) // tempUserInput key
        )
        { token_source.SwitchTo(DEFAULT); }
    }
    catch(ParseException e) {
        // Extract position information from exception
        int[] pos = extractPositionFromToken(e.currentToken);
        if (pos[0] < 0 || pos[1] < 0)
            pos = extractPositionFromToken(token);
        
        String errorMsg = e.getMessage();
        if (errorMsg == null)
            errorMsg = "Invalid property syntax";
        
        // Add warning for recoverable errors (can skip)
        addGpadWarning("Style property error: " + errorMsg, pos[0], pos[1]);
        gpadSkipToSync();
    }
}

/**
 * Unified handler for ~key (reset operation)
 * Syntax: ~key;
 * Sets a reset marker on the property, indicating it should be cleared first.
 * The reset marker can coexist with normal attributes, allowing "clear then set" semantics.
 */
void gpadStyleSheetPropertyDelete(GpadStyleSheet styleSheet) :
{
    Token keyToken;
    String propertyName;
}
{
    keyToken = <GK_DELETE>
    {
        // Convert the property name (check gkNameMaps), but no attribute conversion needed
        String originalKey = keyToken.image.substring(1);
        propertyName = gkNameMaps.getOrDefault(originalKey, originalKey);
        styleSheet.resetProperty(propertyName);
        if ("fixed".equals(originalKey)) {
            java.util.LinkedHashMap<String, String> attrsCheckbox = styleSheet.getProperty("checkbox");
            if(attrsCheckbox != null)
                attrsCheckbox.put("fixed", "false");
        }
    }
}

/**
 * Unified handler for boolean keys (set to true)
 * Syntax: key;
 * Only works for boolean type keys (no value part)
 */
void gpadStyleSheetPropertyBoolean(GpadStyleSheet styleSheet) :
{
    Token keyToken;
}
{
    keyToken = <GK_BOOL>
    {
        String key = keyToken.image;
        setPropertyWithValueConversion(styleSheet, key, "true");
        if ("fixed".equals(key)) {
            java.util.LinkedHashMap<String, String> attrsCheckbox = styleSheet.getProperty("checkbox");
            if(attrsCheckbox != null)
                attrsCheckbox.put("fixed", "true");
        }
    }
}

/**
 * Parses integer property
 * Syntax: key: <integer>;
 */
void gpadStyleSheetPropertyInt(GpadStyleSheet styleSheet) :
{
    Token keyToken;
    Token valueToken;
    String[] converted;
}
{
    keyToken = <GK_INT> <GK_COLON> { token_source.SwitchTo(DEFAULT); }
    valueToken = <FLOAT>
    {
        converted = convertPropertyKey(keyToken.image);
        java.util.LinkedHashMap<String, String> attrs = new java.util.LinkedHashMap<>();
        attrs.put(converted[1], extractIntegerPart(valueToken.image));
        styleSheet.setProperty(converted[0], attrs);
    }
}

/**
 * Parses float property
 * Syntax: key: <float>;
 */
void gpadStyleSheetPropertyFloat(GpadStyleSheet styleSheet) :
{
    Token keyToken;
    Token valueToken;
    String[] converted;
}
{
    keyToken = <GK_FLOAT> <GK_COLON> { token_source.SwitchTo(DEFAULT); }
    valueToken = <FLOAT>
    {
        converted = convertPropertyKey(keyToken.image);
        java.util.LinkedHashMap<String, String> attrs = new java.util.LinkedHashMap<>();
        attrs.put(converted[1], valueToken.image);
        styleSheet.setProperty(converted[0], attrs);
    }
}

/**
 * Parses string property
 * Syntax: key: <string>;
 */
void gpadStyleSheetPropertyStr(GpadStyleSheet styleSheet) :
{
    Token keyToken;
    Token valueToken;
    String val;
    StringBuilder sb = new StringBuilder();
}
{
    keyToken = <GK_STR> <GK_COLON> { token_source.SwitchTo(GK_STR_BLOCK); }
    (
        valueToken = <TEXT> {
            val = valueToken.image;
            val = unescapeString(val.substring(1, val.length() - 1));
            sb.append(val);
        }
        | valueToken = <GK_STR_UNQUOTED> { sb.append(valueToken.image); }
    )+
    { setPropertyWithValueConversion(styleSheet, keyToken.image, sb.toString()); }
}

/**
 * Parses xycoords property
 * Syntax: key: <double> <double>;
 * Value: two double values separated by space (x and y coordinates)
 */
void gpadStyleSheetPropertyXYCoords(GpadStyleSheet styleSheet) :
{
    Token keyToken;
    Token xToken, yToken;
    String[] converted;
}
{
    keyToken = <GK_XYCOORDS> <GK_COLON> { token_source.SwitchTo(GK_VALUE_BLOCK); }
    xToken = <GK_VALUE_float> yToken = <GK_VALUE_float>
    {
        converted = convertPropertyKey(keyToken.image);
        java.util.LinkedHashMap<String, String> attrs = new java.util.LinkedHashMap<>();
        attrs.put("x", xToken.image);
        attrs.put("y", yToken.image);
        styleSheet.setProperty(converted[0], attrs);
    }
}

/**
 * Parses coords property
 * Syntax: coords: x y [z] [w] [v=vx vy vz [vw]] [w=wx wy wz];
 * Parts must appear in order: base coords, optional v=, optional w=
 * Defaults: z=1.0, w=1.0, vw=0.0
 */
void gpadStyleSheetPropertyCoords(GpadStyleSheet styleSheet) :
{
    Token keyToken;
    Token xToken, yToken, zToken = null, wToken = null;
    Token vxToken = null, vyToken = null, vzToken = null, vwToken = null;
    Token wxToken = null, wyToken = null, wzToken = null;
    String[] converted;
}
{
    keyToken = <GK_coords> <GK_COLON> { token_source.SwitchTo(GK_VALUE_BLOCK); }
    // Part 1: x y [z] [w]
    xToken = <GK_VALUE_float> 
    yToken = <GK_VALUE_float>
    (zToken = <GK_VALUE_float>)?
    (wToken = <GK_VALUE_float>)?
    
    // Part 2 (optional): v=vx vy vz [vw]
    (
        <GK_coords_v> <GK_VALUE_equal>
        vxToken = <GK_VALUE_float>
        vyToken = <GK_VALUE_float>
        vzToken = <GK_VALUE_float>
        (vwToken = <GK_VALUE_float>)?
        
        // Part 3 (optional, only if Part 2 exists): w=wx wy wz
        (
            <GK_coords_w> <GK_VALUE_equal>
            wxToken = <GK_VALUE_float>
            wyToken = <GK_VALUE_float>
            wzToken = <GK_VALUE_float>
        )?
    )?
    
    {
        converted = convertPropertyKey(keyToken.image);
        java.util.LinkedHashMap<String, String> attrs = new java.util.LinkedHashMap<>();
        
        // Part 1: x, y, z (default 1.0), w (default 1.0)
        attrs.put("x", xToken.image);
        attrs.put("y", yToken.image);
        attrs.put("z", zToken != null ? zToken.image : "1.0");
        attrs.put("w", wToken != null ? wToken.image : "1.0");
        
        // Part 2: vx, vy, vz, vw (default 0.0)
        if (vxToken != null) {
            attrs.put("vx", vxToken.image);
            attrs.put("vy", vyToken.image);
            attrs.put("vz", vzToken.image);
            attrs.put("vw", vwToken != null ? vwToken.image : "0.0");
            
            // Part 3: wx, wy, wz (only if Part 2 exists)
            if (wxToken != null) {
                attrs.put("wx", wxToken.image);
                attrs.put("wy", wyToken.image);
                attrs.put("wz", wzToken.image);
            }
        }
        
        styleSheet.setProperty(converted[0], attrs);
    }
}

/**
 * Parses RGBA color property
 * Syntax: key: #rrggbb; or key: #rrggbbaa;
 * Hex values are case-insensitive.
 */
void gpadStyleSheetPropertyRGBA(GpadStyleSheet styleSheet) :
{
    Token keyToken;
    Token colorToken;
}
{
    keyToken = <GK_RGBA> <GK_COLON> { token_source.SwitchTo(GK_VALUE_BLOCK); }
    colorToken = <GK_RGBA_HEX_COLOR>
    {
        java.util.LinkedHashMap<String, String> attrs = new java.util.LinkedHashMap<>();
        // Only set property if color format is valid, otherwise silently ignore
        if (parseHexColor(colorToken.image, attrs))
            styleSheet.setProperty(keyToken.image, attrs);
    }
}

/**
 * Parses animation property
 * Syntax: animation: [play|~play] [type step] [speed x];
 * Three parts separated by whitespace, any order, any can be omitted
 */
void gpadStyleSheetPropertyAnimation(GpadStyleSheet styleSheet) :
{
    Token keyToken;
    String playing = null;
    String type = "0";
    String step = null;
    String speed = null;
    Token stepToken = null;
    Token speedToken = null;
}
{
    keyToken = <GK_animation> <GK_COLON>{ token_source.SwitchTo(GK_animation_BLOCK); }
    ( (
        <GK_animation_play> { playing = "true"; } |
        <GK_animation_tilde_play> { playing = "false"; }
    ) | (
        <GK_animation_speed> <GK_animation_equal> (
        speedToken = <TEXT> { speed = speedToken.image.substring(1, speedToken.image.length() - 1); } |
        speedToken = <GK_number> { speed = speedToken.image; }
        )
    ) | ( (
        <GK_animation_plus> { type = "1"; } |
        <GK_animation_minus> { type = "2"; } |
        <GK_animation_equal> { type = "3"; }
        )
        (
        stepToken = <TEXT> { step = stepToken.image.substring(1, stepToken.image.length() - 1); } |
        stepToken = <GK_number> { step = stepToken.image; }
        )?
    ) | (
        stepToken = <TEXT> { step = stepToken.image.substring(1, stepToken.image.length() - 1); } |
        stepToken = <GK_number> { step = stepToken.image; }
    ) )*
    {
        java.util.LinkedHashMap<String, String> attrs = new java.util.LinkedHashMap<>();
        if (playing != null)
            attrs.put("playing", playing);
        if (step != null) {
            attrs.put("type", type);
            attrs.put("step", step);
        }
        if (speed != null)
            attrs.put("speed", speed);
        styleSheet.setProperty(keyToken.image, attrs);
    }
}

/**
 * Parses checkbox property
 * Syntax: checkbox;
 */
void gpadStyleSheetPropertyCheckbox(GpadStyleSheet styleSheet) :
{
    Token keyToken;
}
{
    keyToken = <GK_checkbox>
    {
        java.util.LinkedHashMap<String, String> attrs = new java.util.LinkedHashMap<>();
        java.util.LinkedHashMap<String, String> attrsFixed = styleSheet.getProperty("fixed");
        String fixed = attrsFixed != null? attrsFixed.getOrDefault("val", "false"): "false";
        attrs.put("fixed", fixed);
        styleSheet.setProperty(keyToken.image, attrs);
    }
}

/**
 * Parses slider property
 * Syntax: slider: [min=<表达式>] [max=<表达式>] [width=<浮点数>] [x=<浮点数>] [y=<浮点数>] [vertical|~vertical] [algebra|~algebra] [constant|~constant] [@screen|~@screen] [fixed|~fixed];
 * Note: @screen and fixed are independent properties for the slider, not linked to object-level properties
 */
void gpadStyleSheetPropertySlider(GpadStyleSheet styleSheet) :
{
    Token keyToken;
    Token widthToken;
    Token xToken, yToken;
    String minValue = null;
    String maxValue = null;
    String widthValue = null;
    String xValue = null;
    String yValue = null;
    boolean vertical = false;
    boolean algebra = false;
    boolean constant = false;
    boolean screen = false;
    boolean fixed = false;
    boolean hasVertical = false;
    boolean hasAlgebra = false;
    boolean hasConstant = false;
    boolean hasScreen = false;
    boolean hasFixed = false;
}
{
    keyToken = <GK_slider> <GK_COLON> { token_source.SwitchTo(GK_EXPR_BLOCK); }
    (
        // Parse min=<表达式>
        <GK_slider_min> <GK_slider_equal> { minValue = gpadExpr(); }
    |
        // Parse max=<表达式>
        <GK_slider_max> <GK_slider_equal> { maxValue = gpadExpr(); }
    |
        // Parse width=<浮点数>
        <GK_slider_width> <GK_slider_equal> widthToken = <GK_EXPR_FLOAT> { widthValue = widthToken.image; }
    |
        // Parse x=<浮点数>
        <GK_slider_x> <GK_slider_equal> xToken = <GK_EXPR_FLOAT> { xValue = xToken.image; }
    |
        // Parse y=<浮点数>
        <GK_slider_y> <GK_slider_equal> yToken = <GK_EXPR_FLOAT> { yValue = yToken.image; }
    |
        // Parse vertical flag
        <GK_slider_vertical>
        {
            vertical = true;
            hasVertical = true;
        }
    |
        // Parse ~vertical flag
        <GK_slider_tilde_vertical>
        {
            vertical = false;
            hasVertical = true;
        }
    |
        // Parse algebra flag
        <GK_slider_algebra>
        {
            algebra = true;
            hasAlgebra = true;
        }
    |
        // Parse ~algebra flag
        <GK_slider_tilde_algebra>
        {
            algebra = false;
            hasAlgebra = true;
        }
    |
        // Parse constant flag
        <GK_slider_constant>
        {
            constant = true;
            hasConstant = true;
        }
    |
        // Parse ~constant flag
        <GK_slider_tilde_constant>
        {
            constant = false;
            hasConstant = true;
        }
    |
        // Parse @screen flag
        <GK_slider_screen>
        {
            screen = true;
            hasScreen = true;
        }
    |
        // Parse ~@screen flag
        <GK_slider_tilde_screen>
        {
            screen = false;
            hasScreen = true;
        }
    |
        // Parse fixed flag
        <GK_slider_fixed>
        {
            fixed = true;
            hasFixed = true;
        }
    |
        // Parse ~fixed flag
        <GK_slider_tilde_fixed>
        {
            fixed = false;
            hasFixed = true;
        }
    )*
    {
        java.util.LinkedHashMap<String, String> attrs = new java.util.LinkedHashMap<>();
        
        // Set fixed property (independent from object-level fixed)
        if (hasFixed)
            attrs.put("fixed", String.valueOf(fixed));
        
        // Set absoluteScreenLocation based on @screen flag (independent from object-level @screen)
        if (hasScreen) {
            attrs.put("absoluteScreenLocation", String.valueOf(screen));
        } else if (xValue != null && yValue != null) {
            // If x/y are provided but @screen is not set, default to relative coordinates
            attrs.put("absoluteScreenLocation", "false");
        }
        
        // x/y coordinates: always use from slider attributes if provided
        if (xValue != null)
            attrs.put("x", xValue);
        if (yValue != null)
            attrs.put("y", yValue);
        
        if (minValue != null)
            attrs.put("min", minValue);
        if (maxValue != null)
            attrs.put("max", maxValue);
        if (widthValue != null)
            attrs.put("width", widthValue);
        
        // Set horizontal (inverse of vertical)
        if (hasVertical)
            attrs.put("horizontal", String.valueOf(!vertical));
        
        // Set showAlgebra (mapped from algebra)
        if (hasAlgebra)
            attrs.put("showAlgebra", String.valueOf(algebra));
        
        // Set arbitraryConstant (mapped from constant)
        if (hasConstant)
            attrs.put("arbitraryConstant", String.valueOf(constant));

        styleSheet.setProperty(keyToken.image, attrs);
    }
}

/**
 * Parses tableview property
 * Syntax: tableview: [<整数>] [points|~points];
 * Examples:
 *   tableview: 2 points;     // column=2, points=true
 *   tableview: 1 ~points;    // column=1, points=false
 *   tableview: points;       // no column, points=true
 *   tableview: 3;            // column=3, no points
 *   tableview: ~points;      // no column, points=false
 */
void gpadStyleSheetPropertyTableView(GpadStyleSheet styleSheet) :
{
    Token keyToken;
    Token columnToken = null;
    String columnValue = null;
    boolean points = true;
    boolean hasPoints = false;
}
{
    keyToken = <GK_tableview> <GK_COLON> { token_source.SwitchTo(GK_VALUE_BLOCK); }
    (
        // Parse column number (integer)
        columnToken = <GK_VALUE_float> { columnValue = extractIntegerPart(columnToken.image); }
    |
        // Parse points flag
        <GK_tableview_points>
        {
            points = true;
            hasPoints = true;
        }
    |
        // Parse ~points flag
        <GK_tableview_tilde_points>
        {
            points = false;
            hasPoints = true;
        }
    )*
    {
        java.util.LinkedHashMap<String, String> attrs = new java.util.LinkedHashMap<>();
        
        // Set column if provided
        if (columnValue != null)
            attrs.put("column", columnValue);
        
        // Set points if provided (default is true, so only set if explicitly false)
        if (hasPoints)
            attrs.put("points", String.valueOf(points));
        
        styleSheet.setProperty(keyToken.image, attrs);
    }
}

/**
 * Parses spreadsheetTrace property
 * Syntax: spreadsheetTrace: [trace|~trace] [column=<int>] [row=<int>[/<int>]] 
 *         [reset|~reset] [label|~label] [list|~list] [copy|~copy] [pause|~pause];
 * 
 * row format:
 *   row=12/30    -> traceRow1=12, numRows=30, doRowLimit=true
 *   row=12       -> traceRow1=12, doRowLimit=false, numRows not set
 * 
 * All attributes are optional and can appear in any order.
 */
void gpadStyleSheetPropertySpreadsheetTrace(GpadStyleSheet styleSheet) :
{
    Token keyToken;
    Token intToken = null;
    Token intToken2 = null;
    String column = null;
    String traceRow1 = null;
    String numRows = null;
    boolean trace = false;
    boolean doRowLimit = false;
    boolean reset = false;
    boolean label = true;
    boolean list = false;
    boolean copy = false;
    boolean pause = false;
    boolean hasTrace = false;
    boolean hasReset = false;
    boolean hasLabel = false;
    boolean hasList = false;
    boolean hasCopy = false;
    boolean hasPause = false;
}
{
    keyToken = <GK_spreadsheetTrace> <GK_COLON> { token_source.SwitchTo(GK_VALUE_BLOCK); }
    (
        // Parse trace flag
        <GK_spreadsheetTrace_trace>
        {
            trace = true;
            hasTrace = true;
        }
    |
        // Parse ~trace flag
        <GK_spreadsheetTrace_tilde_trace>
        {
            trace = false;
            hasTrace = true;
        }
    |
        // Parse column=<int>
        <GK_spreadsheetTrace_column> <GK_VALUE_equal> intToken = <GK_VALUE_float>
        {
            column = extractIntegerPart(intToken.image);
        }
    |
        // Parse row=<int> or row=<int>/<int>
        <GK_spreadsheetTrace_row> <GK_VALUE_equal> intToken = <GK_VALUE_float>
        (
            // Optional: /<int> for row limit
            <GK_VALUE_slash> intToken2 = <GK_VALUE_float>
            {
                // Format: row=12/30 -> traceRow1=12, numRows=30, doRowLimit=true
                traceRow1 = extractIntegerPart(intToken.image);
                numRows = extractIntegerPart(intToken2.image);
                doRowLimit = true;
            }
        |
            {
                // Format: row=12 -> traceRow1=12, doRowLimit=false, numRows not set
                traceRow1 = extractIntegerPart(intToken.image);
                doRowLimit = false;
            }
        )
    |
        // Parse reset flag
        <GK_spreadsheetTrace_reset>
        {
            reset = true;
            hasReset = true;
        }
    |
        // Parse ~reset flag
        <GK_spreadsheetTrace_tilde_reset>
        {
            reset = false;
            hasReset = true;
        }
    |
        // Parse label flag
        <GK_VALUE_label>
        {
            label = true;
            hasLabel = true;
        }
    |
        // Parse ~label flag
        <GK_VALUE_tilde_label>
        {
            label = false;
            hasLabel = true;
        }
    |
        // Parse list flag
        <GK_spreadsheetTrace_list>
        {
            list = true;
            hasList = true;
        }
    |
        // Parse ~list flag
        <GK_spreadsheetTrace_tilde_list>
        {
            list = false;
            hasList = true;
        }
    |
        // Parse copy flag
        <GK_spreadsheetTrace_copy>
        {
            copy = true;
            hasCopy = true;
        }
    |
        // Parse ~copy flag
        <GK_spreadsheetTrace_tilde_copy>
        {
            copy = false;
            hasCopy = true;
        }
    |
        // Parse pause flag
        <GK_spreadsheetTrace_pause>
        {
            pause = true;
            hasPause = true;
        }
    |
        // Parse ~pause flag
        <GK_spreadsheetTrace_tilde_pause>
        {
            pause = false;
            hasPause = true;
        }
    )*
    {
        java.util.LinkedHashMap<String, String> attrs = new java.util.LinkedHashMap<>();
        
        // Set trace (optional, only if explicitly set)
        if (hasTrace)
            attrs.put("val", String.valueOf(trace));
        
        // Set column (traceColumn1)
        if (column != null)
            attrs.put("traceColumn1", column);
        
        // Set row-related attributes
        if (traceRow1 != null) {
            attrs.put("traceRow1", traceRow1);
            attrs.put("doRowLimit", String.valueOf(doRowLimit));
            if (numRows != null)
                attrs.put("numRows", numRows);
        }
        
        // Set boolean attributes (only if explicitly set)
        if (hasReset)
            attrs.put("doColumnReset", String.valueOf(reset));
        if (hasLabel)
            attrs.put("showLabel", String.valueOf(label));
        if (hasList)
            attrs.put("showTraceList", String.valueOf(list));
        if (hasCopy)
            attrs.put("doTraceGeoCopy", String.valueOf(copy));
        if (hasPause)
            attrs.put("pause", String.valueOf(pause));
        
        // Only set property if at least one attribute is provided
        if (!attrs.isEmpty())
            styleSheet.setProperty(keyToken.image, attrs);
    }
}

/**
 * Parses eqnStyle property
 * Syntax: eqnStyle: <style>; or eqnStyle: parametric=<letter>;
 * Style values: implicit, explicit, specific, parametric, general, vertex, conic, user
 * When style is "parametric", can optionally specify parameter with =<letter>
 */
void gpadStyleSheetPropertyEqnStyle(GpadStyleSheet styleSheet) :
{
    Token keyToken;
    Token styleToken;
    Token paramToken = null;
    String styleValue;
    String paramValue = null;
}
{
    keyToken = <GK_eqnStyle> <GK_COLON> { token_source.SwitchTo(DEFAULT); }
    styleToken = <LABEL>
    {
        styleValue = styleToken.image;
        // Validate style value
        if (!gkEqnStyleValues.containsKey(styleValue)) {
            // Invalid style value, skip this property
            return;
        }
    }
    (
        <EQUAL> (paramToken = <LABEL> | paramToken = <FLOAT>)
        {
            // Only allow parameter for parametric style
            if ("parametric".equals(styleValue)) {
                String paramStr = paramToken.image;
                // Validate parameter is a single letter (case-insensitive)
                if (paramStr.length() == 1) {
                    char paramChar = paramStr.charAt(0);
                    if ((paramChar >= 'a' && paramChar <= 'z') ||
                        (paramChar >= 'A' && paramChar <= 'Z')) {
                        paramValue = String.valueOf(paramChar);
                    }
                    // If not a letter, paramValue remains null (parameter is ignored)
                }
            }
        }
    )?
    {
        java.util.LinkedHashMap<String, String> attrs = new java.util.LinkedHashMap<>();
        attrs.put("style", styleValue);
        if (paramValue != null)
            attrs.put("parameter", paramValue);
        styleSheet.setProperty(keyToken.image, attrs);
    }
}

/**
 * Parses lineStyle property
 * Syntax: lineStyle: [type] [thickness=value] [hidden[=dashed|show]] [opacity=value] [arrow|~arrow];
 * Five parts separated by whitespace, any order, any can be omitted
 * type: one of gkLineStyleTypeValues keys (pointwise, full, dashedshort, dashedlong, dotted, dasheddotted)
 * thickness: FLOAT value (decimal part ignored)
 * typeHidden: hidden (default), hidden=dashed, or hidden=show
 * opacity: FLOAT value (decimal part ignored)
 * drawArrow: arrow or ~arrow
 */
void gpadStyleSheetPropertyLineStyle(GpadStyleSheet styleSheet) :
{
    Token keyToken;
    String type = null;
    String thickness = null;
    String typeHidden = null;
    String opacity = null;
    String drawArrow = null;
    Token floatToken = null;
}
{
    keyToken = <GK_lineStyle> <GK_COLON> { token_source.SwitchTo(GK_VALUE_BLOCK); }
    ( (
        // Parse type (no prefix)
        <GK_lineStyle_type_pointwise> { type = "pointwise"; } |
        <GK_lineStyle_type_full> { type = "full"; } |
        <GK_lineStyle_type_dashedshort> { type = "dashedshort"; } |
        <GK_lineStyle_type_dashedlong> { type = "dashedlong"; } |
        <GK_lineStyle_type_dotted> { type = "dotted"; } |
        <GK_lineStyle_type_dasheddotted> { type = "dasheddotted"; }
    ) | (
        // Parse thickness=value
        <GK_lineStyle_thickness> <GK_VALUE_equal> floatToken = <GK_VALUE_float>
        {
            thickness = extractIntegerPart(floatToken.image);
        }
    ) | (
        // Parse hidden[=dashed|show]
        <GK_lineStyle_hidden>
        (
            <GK_VALUE_equal> (
                <GK_lineStyle_dashed> { typeHidden = "dashed"; } |
                <GK_lineStyle_show> { typeHidden = "show"; }
            )
        )?
        {
            // If no value specified, default to empty string (which maps to "0")
            if (typeHidden == null) {
                typeHidden = "";
            }
        }
    ) | (
        // Parse opacity=value
        <GK_lineStyle_opacity> <GK_VALUE_equal> floatToken = <GK_VALUE_float>
        {
            opacity = extractIntegerPart(floatToken.image);
        }
    ) | (
        // Parse arrow or ~arrow
        <GK_lineStyle_arrow> { drawArrow = "true"; } |
        <GK_lineStyle_tilde_arrow> { drawArrow = "false"; }
    )     )*
    {
        java.util.LinkedHashMap<String, String> attrs = new java.util.LinkedHashMap<>();
        
        // Set default values if not provided
        // Default type: 0 (full), default thickness: 5
        if (type != null) {
            // Convert type key to XML value using gkLineStyleTypeValues
            String typeValue = gkLineStyleTypeValues.get(type);
            if (typeValue != null) {
                attrs.put("type", typeValue);
            } else {
                // If type not found in map, use default
                attrs.put("type", "0");
            }
        } else {
            // Default line type: full (0)
            attrs.put("type", "0");
        }
        
        if (thickness != null) {
            attrs.put("thickness", thickness);
        } else {
            // Default line thickness: 5
            attrs.put("thickness", "5");
        }
        
        if (typeHidden != null) {
            // Convert typeHidden to XML value using gkLineStyleTypeHiddenValues
            String typeHiddenValue = gkLineStyleTypeHiddenValues.get(typeHidden);
            if (typeHiddenValue != null) {
                attrs.put("typeHidden", typeHiddenValue);
            }
        }
        if (opacity != null) {
            attrs.put("opacity", opacity);
        }
        if (drawArrow != null) {
            attrs.put("drawArrow", drawArrow);
        }
        // Always set property since we now always have type and thickness
        styleSheet.setProperty(keyToken.image, attrs);
    }
}

/**
 * Parses boundingBox property
 * Syntax: boundingBox: width=<value> height=<value>;
 * Both width and height are integers (FLOAT matched, decimal part ignored)
 */
void gpadStyleSheetPropertyBoundingBox(GpadStyleSheet styleSheet) :
{
    Token keyToken;
    String width = null;
    String height = null;
    Token floatToken = null;
}
{
    keyToken = <GK_boundingBox> <GK_COLON> { token_source.SwitchTo(GK_VALUE_BLOCK); }
    ( (
        // Parse width=value
        <GK_VALUE_width> <GK_VALUE_equal> floatToken = <GK_VALUE_float>
        {
            width = extractIntegerPart(floatToken.image);
        }
    ) | (
        // Parse height=value
        <GK_VALUE_height> <GK_VALUE_equal> floatToken = <GK_VALUE_float>
        {
            height = extractIntegerPart(floatToken.image);
        }
    ) )*
    {
        java.util.LinkedHashMap<String, String> attrs = new java.util.LinkedHashMap<>();
        if (width != null)
            attrs.put("width", width);
        if (height != null)
            attrs.put("height", height);
        if (!attrs.isEmpty())
            styleSheet.setProperty(keyToken.image, attrs);
    }
}

/**
 * Parses contentSize property
 * Syntax: contentSize: width=<value> height=<value>;
 * Both width and height are floats
 */
void gpadStyleSheetPropertyContentSize(GpadStyleSheet styleSheet) :
{
    Token keyToken;
    String width = null;
    String height = null;
    Token floatToken = null;
}
{
    keyToken = <GK_contentSize> <GK_COLON> { token_source.SwitchTo(GK_VALUE_BLOCK); }
    ( (
        // Parse width=value
        <GK_VALUE_width> <GK_VALUE_equal> floatToken = <GK_VALUE_float>
        {
            width = floatToken.image;
        }
    ) | (
        // Parse height=value
        <GK_VALUE_height> <GK_VALUE_equal> floatToken = <GK_VALUE_float>
        {
            height = floatToken.image;
        }
    ) )*
    {
        java.util.LinkedHashMap<String, String> attrs = new java.util.LinkedHashMap<>();
        if (width != null)
            attrs.put("width", width);
        if (height != null)
            attrs.put("height", height);
        if (!attrs.isEmpty())
            styleSheet.setProperty(keyToken.image, attrs);
    }
}

/**
 * Parses tempUserInput property
 * Syntax: tempUserInput: eval="<string>" display="<string>";
 * Both eval and display are quoted strings (required to be quoted)
 * Order can be arbitrary, both are optional
 */
void gpadStyleSheetPropertyTempUserInput(GpadStyleSheet styleSheet) :
{
    Token keyToken;
    String eval = null;
    String display = null;
    Token textToken;
}
{
    keyToken = <GK_tempUserInput> <GK_COLON> { token_source.SwitchTo(GK_EXPR_BLOCK); }
    ( (
        // Parse eval="<string>"
        <GK_tempUserInput_eval> <GK_slider_equal> 
        textToken = <TEXT>
        {
            eval = unescapeString(textToken.image.substring(1, textToken.image.length() - 1));
        }
    ) | (
        // Parse display="<string>"
        <GK_tempUserInput_display> <GK_slider_equal>
        textToken = <TEXT>
        {
            display = unescapeString(textToken.image.substring(1, textToken.image.length() - 1));
        }
    ) )*
    {
        java.util.LinkedHashMap<String, String> attrs = new java.util.LinkedHashMap<>();
        if (eval != null)
            attrs.put("eval", eval);
        if (display != null)
            attrs.put("display", display);
        if (!attrs.isEmpty())
            styleSheet.setProperty(keyToken.image, attrs);
    }
}

/**
 * Parses cropBox property
 * Syntax: cropBox: x=<value> y=<value> width=<value> height=<value> [cropped|~cropped];
 * x, y, width, height are floats, cropped is boolean (cropped for true, ~cropped for false)
 */
void gpadStyleSheetPropertyCropBox(GpadStyleSheet styleSheet) :
{
    Token keyToken;
    String x = null;
    String y = null;
    String width = null;
    String height = null;
    String cropped = null;
    Token floatToken = null;
}
{
    keyToken = <GK_cropBox> <GK_COLON> { token_source.SwitchTo(GK_VALUE_BLOCK); }
    ( (
        // Parse x=value
        <GK_cropBox_x> <GK_VALUE_equal> floatToken = <GK_VALUE_float>
        {
            x = floatToken.image;
        }
    ) | (
        // Parse y=value
        <GK_cropBox_y> <GK_VALUE_equal> floatToken = <GK_VALUE_float>
        {
            y = floatToken.image;
        }
    ) | (
        // Parse width=value
        <GK_VALUE_width> <GK_VALUE_equal> floatToken = <GK_VALUE_float>
        {
            width = floatToken.image;
        }
    ) | (
        // Parse height=value
        <GK_VALUE_height> <GK_VALUE_equal> floatToken = <GK_VALUE_float>
        {
            height = floatToken.image;
        }
    ) | (
        // Parse cropped or ~cropped
        <GK_cropBox_cropped> { cropped = "true"; } |
        <GK_cropBox_tilde_cropped> { cropped = "false"; }
    ) )*
    {
        java.util.LinkedHashMap<String, String> attrs = new java.util.LinkedHashMap<>();
        if (x != null)
            attrs.put("x", x);
        if (y != null)
            attrs.put("y", y);
        if (width != null)
            attrs.put("width", width);
        if (height != null)
            attrs.put("height", height);
        if (cropped != null)
            attrs.put("cropped", cropped);
        if (!attrs.isEmpty())
            styleSheet.setProperty(keyToken.image, attrs);
    }
}

/**
 * Parses dimensions property
 * Syntax: dimensions: width=<value> height=<value> [angle=<value>] [scaled|~scaled];
 * width, height, angle are floats, scaled is boolean (scaled for true, ~scaled for false)
 * Note: unscaled default is true, so we use scaled (inverse) in gpad syntax
 */
void gpadStyleSheetPropertyDimensions(GpadStyleSheet styleSheet) :
{
    Token keyToken;
    String width = null;
    String height = null;
    String angle = null;
    String scaled = null;
    Token floatToken = null;
}
{
    keyToken = <GK_dimensions> <GK_COLON> { token_source.SwitchTo(GK_VALUE_BLOCK); }
    ( (
        // Parse width=value
        <GK_VALUE_width> <GK_VALUE_equal> floatToken = <GK_VALUE_float>
        {
            width = floatToken.image;
        }
    ) | (
        // Parse height=value
        <GK_VALUE_height> <GK_VALUE_equal> floatToken = <GK_VALUE_float>
        {
            height = floatToken.image;
        }
    ) | (
        // Parse angle=value
        <GK_dimensions_angle> <GK_VALUE_equal> floatToken = <GK_VALUE_float>
        {
            angle = floatToken.image;
        }
    ) | (
        // Parse scaled or ~scaled
        <GK_dimensions_scaled> { scaled = "true"; } |
        <GK_dimensions_tilde_scaled> { scaled = "false"; }
    ) )*
    {
        java.util.LinkedHashMap<String, String> attrs = new java.util.LinkedHashMap<>();
        if (width != null)
            attrs.put("width", width);
        if (height != null)
            attrs.put("height", height);
        if (angle != null)
            attrs.put("angle", angle);
        if (scaled != null) {
            // Convert scaled to unscaled (inverse)
            attrs.put("unscaled", "true".equals(scaled) ? "false" : "true");
        }
        if (!attrs.isEmpty())
            styleSheet.setProperty(keyToken.image, attrs);
    }
}

/**
 * Parses font property
 * Syntax: font: [serif|~serif] [*sizeM] [plain|bold|italic|bold italic|italic bold];
 * serif: serif (true) or ~serif (false), default is false
 * sizeM: multiplier (float), default is 1.0
 * style: plain (0), bold (1), italic (2), or bold italic/italic bold (3)
 */
void gpadStyleSheetPropertyFont(GpadStyleSheet styleSheet) :
{
    Token keyToken;
    String serif = null;
    String sizeM = null;
    Token floatToken = null;
    boolean plain = false;
    boolean bold = false;
    boolean italic = false;
}
{
    keyToken = <GK_font> <GK_COLON> { token_source.SwitchTo(GK_VALUE_BLOCK); }
    ( (
        // Parse serif or ~serif
        <GK_font_serif> { serif = "true"; } |
        <GK_font_tilde_serif> { serif = "false"; }
    ) | (
        // Parse *sizeM
        <GK_VALUE_star> floatToken = <GK_VALUE_float> { sizeM = floatToken.image; }
    ) | (
        // Parse style keywords (plain, bold, italic)
        // Note: plain resets style, but if bold/italic appear after plain, they override
        <GK_font_plain> { plain = true; bold = false; italic = false; } |
        <GK_font_bold> { bold = true; } |
        <GK_font_italic> { italic = true; }
    ) )*
    {
        java.util.LinkedHashMap<String, String> attrs = new java.util.LinkedHashMap<>();
        if (serif != null)
            attrs.put("serif", serif);
        if (sizeM != null)
            attrs.put("sizeM", sizeM);
        if (plain || bold || italic) // style = bit-OR of bold(1) and italic(2)
            attrs.put("style", bold? (italic? "3": "1"): (italic? "2": "0"));
        
        if (!attrs.isEmpty())
            styleSheet.setProperty(keyToken.image, attrs);
    }
}

/**
 * Parses show property
 * Syntax: show: [object|~object] [label|~label] [ev1|~ev1] [ev2|~ev2] [3d|~3d] [plane|~plane];
 * object: object (true) or ~object (false), default is true
 * label: label (true) or ~label (false), default is true
 * ev1: clear bit 0 (mask=1), ~ev1: set bit 0
 * ev2: set bit 1 (mask=2), ~ev2: clear bit 1
 * 3d: set bit 2 (mask=4) and clear bit 3 (mask=8), ~3d: clear bit 2 and set bit 3
 * plane: set bit 4 (mask=16) and clear bit 5 (mask=32), ~plane: clear bit 4 and set bit 5
 * ev attribute is calculated as OR of all bitmasks, only set if at least one ev-related flag is present
 */
void gpadStyleSheetPropertyShow(GpadStyleSheet styleSheet) :
{
    Token keyToken;
    String object = null;
    String label = null;
    int ev = 0;
    boolean hasEvFlags = false;
}
{
    keyToken = <GK_show> <GK_COLON> { token_source.SwitchTo(GK_VALUE_BLOCK); }
    ( (
        // Parse object or ~object
        <GK_show_object> { object = "true"; } |
        <GK_show_tilde_object> { object = "false"; }
    ) | (
        // Parse label or ~label
        <GK_VALUE_label> { label = "true"; } |
        <GK_VALUE_tilde_label> { label = "false"; }
    ) | (
        // Parse ev1 or ~ev1 (bit 0, mask=1)
        <GK_show_ev1> { ev &= ~1; hasEvFlags = true; } |
        <GK_show_tilde_ev1> { ev |= 1; hasEvFlags = true; }
    ) | (
        // Parse ev2 or ~ev2 (bit 1, mask=2)
        <GK_show_ev2> { ev |= 2; hasEvFlags = true; } |
        <GK_show_tilde_ev2> { ev &= ~2; hasEvFlags = true; }
    ) | (
        // Parse 3d or ~3d (bit 2=4, bit 3=8)
        <GK_show_3d> { ev |= 4; ev &= ~8; hasEvFlags = true; } |
        <GK_show_tilde_3d> { ev &= ~4; ev |= 8; hasEvFlags = true; }
    ) | (
        // Parse plane or ~plane (bit 4=16, bit 5=32)
        <GK_show_plane> { ev |= 16; ev &= ~32; hasEvFlags = true; } |
        <GK_show_tilde_plane> { ev &= ~16; ev |= 32; hasEvFlags = true; }
    ) )*
    {
        java.util.LinkedHashMap<String, String> attrs = new java.util.LinkedHashMap<>();
        if (object != null)
            attrs.put("object", object);
        if (label != null)
            attrs.put("label", label);
        if (hasEvFlags)
            attrs.put("ev", String.valueOf(ev));
        
        if (!attrs.isEmpty())
            styleSheet.setProperty(keyToken.image, attrs);
    }
}

/**
 * Parses startPoint property
 * Syntax: startPoint: corner [| corner]*;
 * Each corner consists of three optional parts:
 *   1. absolute | ~absolute (optional, default ~absolute)
 *   2. TEXT (quoted expression, optional)
 *   3. x y [z] (coordinates, optional)
 * At least one of part 2 or part 3 must be present.
 */
void gpadStyleSheetPropertyStartPoint(GpadStyleSheet styleSheet) :
{
    Token keyToken;
    StringBuilder serialized = new StringBuilder();
    boolean firstCorner = true;
}
{
    keyToken = <GK_startPoint> <GK_COLON> { token_source.SwitchTo(GK_EXPR_BLOCK); }
    (
        gpadStartPointCorner(serialized, firstCorner) { firstCorner = false; }
        (
            <GK_startPoint_pipe>
            gpadStartPointCorner(serialized, firstCorner) { firstCorner = false; }
        )*
    )
    {
        // Store serialized string in a special attribute
        java.util.LinkedHashMap<String, String> attrs = new java.util.LinkedHashMap<>();
        attrs.put("_corners", serialized.toString());
        styleSheet.setProperty(keyToken.image, attrs);
    }
}

/**
 * Parses a single startPoint corner and serializes it directly to the StringBuilder.
 * Three optional parts (at least one of part 2 or part 3 must be present):
 *   1. absolute | ~absolute (optional, default ~absolute)
 *   2. TEXT (quoted expression, optional)
 *   3. x y [z] (coordinates, optional)
 * 
 * Parts can appear in any order, but at least one of part 2 or part 3 must be present.
 * 
 * Serialization format: [absolute byte][type byte][content]
 *   - absolute byte: \u0002=true, \u0003=false
 *   - type byte: \u0002=exp, \u0003=x/y/z
 *   - content: if exp, then exp string; if x/y/z, then "x,y,z" (z optional, no trailing comma)
 */
void gpadStartPointCorner(StringBuilder serialized, boolean firstCorner) :
{
    Boolean absolute1 = null;
    Boolean absolute2 = null;
    String[] cornerData = new String[4]; // [0]=exp, [1]=x, [2]=y, [3]=z
}
{
    ( absolute1 = gpadStartPointCornerAbsolute() )?
    gpadStartPointCornerExpOrXyz(cornerData)
    ( absolute2 = gpadStartPointCornerAbsolute() )?
    {
        Boolean absolute = absolute2 != null? absolute2: absolute1;
        boolean isAbsolute = absolute != null && absolute;
        
        // Serialize corner using helper class
        GpadSerializer.serializeStartPointCorner(serialized, firstCorner, isAbsolute, cornerData);
    }
}

/**
 * Parses `absolue` of a single startPoint corner.
 *   absolute | ~absolute
 */
boolean gpadStartPointCornerAbsolute() :
{
    boolean result = false;
}
{
    (
        <GK_startPoint_absolute> { result = true; }
        |
        <GK_startPoint_tilde_absolute> { result = false; }
    )
    {
        return result;
    }
}

void gpadStartPointCornerExpOrXyz(String[] cornerData) :
{
    Token textToken;
    Token xToken;
    Token yToken;
    Token zToken = null;
}
{
    // cornerData[0] = exp, [1] = x, [2] = y, [3] = z
    textToken = <TEXT>
    {
        cornerData[0] = unescapeString(textToken.image.substring(1, textToken.image.length() - 1));
    }
    |
    xToken = <GK_EXPR_FLOAT>
    yToken = <GK_EXPR_FLOAT>
    ( zToken = <GK_EXPR_FLOAT> )?
    {
        cornerData[1] = xToken.image;
        cornerData[2] = yToken.image;
        cornerData[3] = zToken != null? zToken.image: "1";
    }
}

/**
 * Helper rule to parse an expression (either TEXT or full expression)
 * Returns the parsed string value with escape sequences processed
 * Supports GLABEL, numbers, some operations, and function calls
 */
String gpadExpr() :
{
    Token textToken = null;
    StringBuilder sb = new StringBuilder();
    String exprValue = null;
}
{
    (
        textToken = <TEXT>
        {
            String text = textToken.image;
            exprValue = unescapeString(text.substring(1, text.length() - 1));
        }
    |
        { sb = new StringBuilder(); }
        gpadExprTerm(sb)
        { exprValue = sb.toString(); }
    )
    { return exprValue; }
}

/**
 * Parse a label that can be either a keyword (such as rgb...) or a regular label
 * This allows these keywords to be used as variable names in expressions
 * Note: @screen is not included as it contains @ symbol and is not a valid identifier
 */
Token gpadExprLabel() :
{
    Token labelToken = null;
}
{
    (
        labelToken = <GK_objColor_rgb> |
        labelToken = <GK_objColor_hsv> |
        labelToken = <GK_objColor_hsl> |
        labelToken = <GK_objColor_inverse> |
        labelToken = <GK_startPoint_absolute> |
        labelToken = <GK_slider_min> |
        labelToken = <GK_slider_max> |
        labelToken = <GK_slider_width> |
        labelToken = <GK_slider_x> |
        labelToken = <GK_slider_y> |
        labelToken = <GK_slider_vertical> |
        labelToken = <GK_slider_algebra> |
        labelToken = <GK_slider_constant> |
        labelToken = <GK_slider_fixed> |
        labelToken = <GK_tempUserInput_eval> |
        labelToken = <GK_tempUserInput_display> |
        labelToken = <GK_EXPR_LABEL>
    )
    { return labelToken; }
}

/**
 * Parse expression term (handles + and - operations, lowest priority)
 * term = factor (("+" | "-") factor)*
 */
void gpadExprTerm(StringBuilder sb) :
{
    Token opToken = null;
}
{
    gpadExprFactor(sb)
    (
        (opToken = <GK_EXPR_plus> | opToken = <GK_EXPR_minus>)
        {
            sb.append(opToken.image);
        }
        gpadExprFactor(sb)
    )*
}

/**
 * Parse expression factor (handles * and / operations, higher priority)
 * factor = power (("*" | "/") power)*
 */
void gpadExprFactor(StringBuilder sb) :
{
    Token opToken = null;
}
{
    gpadExprPower(sb)
    (
        (opToken = <GK_EXPR_multiply> | opToken = <GK_EXPR_divide>)
        {
            sb.append(opToken.image);
        }
        gpadExprPower(sb)
    )*
}

/**
 * Parse expression power (handles ^ operation, highest priority, right-associative)
 * power = atom ("^" power)?
 */
void gpadExprPower(StringBuilder sb) :
{
    Token opToken = null;
}
{
    gpadExprAtom(sb)
    (
        opToken = <GK_EXPR_power>
        {
            sb.append(opToken.image);
        }
        gpadExprPower(sb)
    )?
}

/**
 * Parse expression atom (highest priority, handles labels, numbers, function calls, parentheses, unary minus)
 * atom = GLABEL | INTEGER | FLOAT | functionCall | "(" term ")" | "-" atom
 */
void gpadExprAtom(StringBuilder sb) :
{
    Token labelToken = null;
    Token intToken = null;
    Token floatToken = null;
    Token funcNameToken = null;
    Token opToken = null;
    Token lparenToken = null;
    Token rparenToken = null;
}
{
    (
        // Function call: gpadExprLabel "(" [arg1] ["," arg2] ... ")"
        // Use LOOKAHEAD to distinguish function call from plain label
        LOOKAHEAD(gpadExprLabel() <GK_EXPR_lparen>)
        funcNameToken = gpadExprLabel()
        lparenToken = <GK_EXPR_lparen>
        {
            sb.append(funcNameToken.image);
            sb.append(lparenToken.image);
        }
        (
            gpadExprTerm(sb)
            (
                <GK_EXPR_comma> { sb.append(","); }
                gpadExprTerm(sb)
            )*
        )?
        rparenToken = <GK_EXPR_rparen> { sb.append(rparenToken.image); }
    |
        // gpadExprLabel (label, not a function call, includes x, y, z, rgb, min, max, etc.)
        labelToken = gpadExprLabel() { sb.append(labelToken.image); }
    |
        // NUMBER (integer or float)
        floatToken = <GK_EXPR_FLOAT> { sb.append(floatToken.image); }
    |
        // Parenthesized expression: "(" term ")"
        lparenToken = <GK_EXPR_lparen> { sb.append(lparenToken.image); }
        gpadExprTerm(sb)
        rparenToken = <GK_EXPR_rparen> { sb.append(rparenToken.image); }
    |
        // Unary minus: "-" atom
        opToken = <GK_EXPR_minus> { sb.append(opToken.image); }
        gpadExprAtom(sb)
    )
}

/**
 * Parses objColor property
 * Syntax: objColor: [#rrggbbaa | rgb(...) | hsv(...) | hsl(...)] [fill=...] [angle=...] [dist=...] [image=...] [symbol=...] [inverse|~inverse]
 */
void gpadStyleSheetPropertyObjColor(GpadStyleSheet styleSheet) :
{
    Token keyToken;
    Token colorToken = null;
    Token exprToken = null;
    Token textToken = null;
    String colorSpace = "0";
    String dynamicr = null;
    String dynamicg = null;
    String dynamicb = null;
    String dynamica = null;
    String fillType = null;
    String hatchAngle = null;
    String hatchDistance = null;
    String image = null;
    String fillSymbol = null;
    String inverseFill = null;
    String value = null;
}
{
    keyToken = <GK_objColor> <GK_COLON> { token_source.SwitchTo(GK_EXPR_BLOCK); }
    (
        // Parse static color: #rrggbb or #rrggbbaa
        colorToken = <GK_objColor_RGBA_HEX_COLOR>
    | 
        // Parse dynamic color: rgb(...), hsv(...), or hsl(...)
        (
            // 0:COLORSPACE_RGB (default), 1:COLORSPACE_HSB, 2:COLORSPACE_HSL
            <GK_objColor_rgb> { colorSpace = "0"; } |
            <GK_objColor_hsv> { colorSpace = "1"; } |
            <GK_objColor_hsl> { colorSpace = "2"; }
        )
        <GK_EXPR_lparen>
        // First parameter (r/h/s)
        dynamicr = gpadExpr()
        <GK_EXPR_comma>
        // Second parameter (g/s/s)
        dynamicg = gpadExpr()
        <GK_EXPR_comma>
        // Third parameter (b/v/l)
        dynamicb = gpadExpr()
        [
            <GK_EXPR_comma>
            // Fourth parameter (alpha, optional)
            dynamica = gpadExpr()
        ]
        <GK_EXPR_rparen>
    )?
    (
        // Parse fill=xxx (fillType is lowercase letters only)
        exprToken = <GK_objColor_fill_equals_value>
        {
            fillType = extractValueAfterEquals(exprToken.image);
        }
    |
        // Parse angle=xxx (hatchAngle is digits only)
        exprToken = <GK_objColor_angle_equals_value>
        {
            hatchAngle = extractValueAfterEquals(exprToken.image);
        }
    |
        // Parse dist=xxx (hatchDistance is digits only)
        exprToken = <GK_objColor_dist_equals_value>
        {
            hatchDistance = extractValueAfterEquals(exprToken.image);
        }
    |
        exprToken = <GK_objColor_image_equals_value>
        {
            value = extractValueAfterEquals(exprToken.image);
            if (value != null) {
                // Check if it's a quoted string (starts and ends with ")
                if (value.startsWith("\"") && value.endsWith("\"")) {
                    // Handle quoted string with escape sequences
                    String quoted = value.substring(1, value.length() - 1); // Remove surrounding quotes
                    image = unescapeString(quoted);
                } else {
                    // Unquoted string, use as-is
                    image = value;
                }
            }
        }
    |
        // Parse symbol=x (fillSymbol is a single printable unicode character)
        exprToken = <GK_objColor_symbol_equals_value>
        {
            value = extractValueAfterEquals(exprToken.image);
            if (value != null) {
                // Check if it's a quoted string (starts and ends with ")
                if (value.startsWith("\"") && value.endsWith("\"")) {
                    // Handle quoted string: take first character only, no escape processing
                    String quoted = value.substring(1, value.length() - 1); // Remove surrounding quotes
                    if (quoted.length() > 0) {
                        fillSymbol = quoted.substring(0, 1); // Take first character only
                    }
                } else {
                    // Unquoted string, use as-is (should be single character)
                    fillSymbol = value;
                }
            }
        }
    |
        // Parse inverse or ~inverse
        <GK_objColor_inverse> { inverseFill = "true"; } |
        <GK_objColor_tilde_inverse> { inverseFill = "false"; }
    )*
    {
        java.util.LinkedHashMap<String, String> attrs = new java.util.LinkedHashMap<>();
        
        // Handle static color
        if (colorToken != null)
            parseHexColor(colorToken.image, attrs);
        
        if (dynamicr != null && dynamicg != null && dynamicb != null) {
            attrs.put("dynamicr", dynamicr);
            attrs.put("dynamicg", dynamicg);
            attrs.put("dynamicb", dynamicb);
            if (dynamica != null)
                attrs.put("dynamica", dynamica);
            attrs.put("colorSpace", colorSpace);
        }
        
        // Handle fillType and its constraints
        if (fillType != null) {
            String fillTypeXML = GpadStyleMaps.FILL_TYPE_MAP.get(fillType);
            if (fillTypeXML != null) {
                attrs.put("fillType", fillTypeXML);
                // Check if fillType is a HATCH type (1-8, excluding 0=STANDARD and 9=IMAGE)
                // HATCH types require hatchAngle and hatchDistance
                try {
                    int fillTypeInt = Integer.parseInt(fillTypeXML);
                    if (fillTypeInt >= 1 && fillTypeInt <= 8) {
                        // HATCH type, ensure angle and dist are set
                        if (hatchAngle == null) {
                            hatchAngle = "45"; // Default hatch angle
                        }
                        if (hatchDistance == null) {
                            hatchDistance = "10"; // Default hatch distance
                        }
                    }
                } catch (NumberFormatException e) {
                    // Ignore parsing errors
                }
            }
        }
        
        // If symbol is set but fillType is not explicitly set, set fillType = SYMBOLS
        // Note: If fillType is already set (e.g., fill=crosshatch), don't override it
        if (fillSymbol != null && fillType == null) {
            // Set fillType to SYMBOLS (which is a HATCH type)
            String symbolsFillType = GpadStyleMaps.FILL_TYPE_MAP.get("symbols");
            if (symbolsFillType != null) {
                fillType = "symbols";
                attrs.put("fillType", symbolsFillType);
                // SYMBOLS is a HATCH type, ensure angle and dist are set
                if (hatchAngle == null) {
                    hatchAngle = "45";
                }
                if (hatchDistance == null) {
                    hatchDistance = "10";
                }
            }
        }
        
        // Handle hatchAngle and hatchDistance constraints
        if (hatchAngle != null) {
            attrs.put("hatchAngle", hatchAngle);
            // If angle is set but distance is not, set default distance to 10
            // (required by ConsElementXMLHandler.java line 1931-1932)
            if (hatchDistance == null) {
                hatchDistance = "10";
            }
        }
        if (hatchDistance != null)
            attrs.put("hatchDistance", hatchDistance);
        
        if (image != null)
            attrs.put("image", image);
        if (fillSymbol != null)
            attrs.put("fillSymbol", fillSymbol);
        if (inverseFill != null)
            attrs.put("inverseFill", inverseFill);
        
        if (!attrs.isEmpty())
            styleSheet.setProperty(keyToken.image, attrs);
    }
}

/**
 * Parses barTag property
 * Syntax: barTag: bar=<number> [#rrggbbaa] [fill=...] [angle=...] [dist=...] [image=...] [symbol=...] | bar=<number> ...
 * Multiple bar styles separated by |
 */
void gpadStyleSheetPropertyBarTag(GpadStyleSheet styleSheet) :
{
    Token keyToken;
    StringBuilder serialized = new StringBuilder();
}
{
    keyToken = <GK_barTag> <GK_COLON> { token_source.SwitchTo(GK_EXPR_BLOCK); }
    (
        gpadBarTagBar(serialized)
        (
            <GK_startPoint_pipe>
            gpadBarTagBar(serialized)
        )*
    )
    {
        // Store serialized string in a special attribute
        java.util.LinkedHashMap<String, String> attrs = new java.util.LinkedHashMap<>();
        attrs.put("_barTags", serialized.toString());
        styleSheet.setProperty(keyToken.image, attrs);
    }
}

/**
 * Parses a single barTag bar and serializes it directly to the StringBuilder.
 * Syntax: [bar=<number>] [#rrggbbaa] [fill=...] [angle=...] [dist=...] [image=...] [symbol=...]
 * All attributes can appear in any order. bar=<number> is required (checked at end).
 * 
 * Serialization format: [length char][barNumber char][flags char][属性值序列]
 *   - length: total length of barNumber + flags + 属性值序列 (excluding length itself)
 *   - barNumber: 1 char (0-65535)
 *   - flags: 1 char, bit flags
 *     bit 0 (0x01): barColor (r, g, b)
 *     bit 1 (0x02): barAlpha
 *     bit 2 (0x04): barFillType
 *     bit 3 (0x08): barHatchAngle
 *     bit 4 (0x10): barHatchDistance
 *     bit 5 (0x20): barImage (字符串，以 ETX 结尾)
 *     bit 6 (0x40): barSymbol
 *   - 属性值序列（按 flags 顺序）
 */
void gpadBarTagBar(StringBuilder serialized) :
{
    Token exprToken = null;
    Token colorToken = null;
    String barNumber = null;
    int[] rgba = { -1, -1, -1, -1};
    String fillType = null;
    String hatchAngle = null;
    String hatchDistance = null;
    String image = null;
    String fillSymbol = null;
    String value = null;
}
{
    (
        // Parse bar=<number> (required, but can appear anywhere)
        exprToken = <GK_barTag_bar_equals_value>
        {
            barNumber = extractValueAfterEquals(exprToken.image);
        }
    |
        // Parse color: #rrggbb or #rrggbbaa (optional, can appear anywhere)
        colorToken = <GK_objColor_RGBA_HEX_COLOR>
        {
            parseHexColorToArray(colorToken.image, rgba);
        }
    |
        // Parse fill=xxx
        exprToken = <GK_objColor_fill_equals_value>
        {
            fillType = extractValueAfterEquals(exprToken.image);
        }
    |
        // Parse angle=xxx
        exprToken = <GK_objColor_angle_equals_value>
        {
            hatchAngle = extractValueAfterEquals(exprToken.image);
        }
    |
        // Parse dist=xxx
        exprToken = <GK_objColor_dist_equals_value>
        {
            hatchDistance = extractValueAfterEquals(exprToken.image);
        }
    |
        // Parse image=xxx
        exprToken = <GK_objColor_image_equals_value>
        {
            value = extractValueAfterEquals(exprToken.image);
            if (value != null) {
                if (value.startsWith("\"") && value.endsWith("\"")) {
                    String quoted = value.substring(1, value.length() - 1);
                    image = unescapeString(quoted);
                } else {
                    image = value;
                }
            }
        }
    |
        // Parse symbol=xxx
        exprToken = <GK_objColor_symbol_equals_value>
        {
            value = extractValueAfterEquals(exprToken.image);
            if (value != null) {
                if (value.startsWith("\"") && value.endsWith("\"")) {
                    if (value.length() > 2)
                        fillSymbol = value.substring(1, 2);
                }
                else if (value.length() > 0)
                    fillSymbol = value.substring(0, 1);
            }
        }
    )*
    
    {
        if (barNumber == null || barNumber.isEmpty()) // barNumber is required, skip this bar
            return;
        
        // Handle fillType and its constraints (similar to objColor)
        String fillTypeXML = null;
        if (fillType != null) {
            fillTypeXML = GpadStyleMaps.FILL_TYPE_MAP.get(fillType);
            if (fillTypeXML != null) {
                // Check if fillType is a HATCH type (1-8, excluding 0=STANDARD and 9=IMAGE)
                try {
                    int fillTypeInt = Integer.parseInt(fillTypeXML);
                    if (fillTypeInt >= 1 && fillTypeInt <= 8) {
                        // HATCH type, ensure angle and dist are set
                        if (hatchAngle == null)
                            hatchAngle = "45"; // Default hatch angle
                        if (hatchDistance == null)
                            hatchDistance = "10"; // Default hatch distance
                    }
                } catch (NumberFormatException e) {
                    // Ignore parsing errors
                }
            }
        }
        
        // If symbol is set but fillType is not explicitly set, set fillType = SYMBOLS
        if (fillSymbol != null && fillTypeXML == null) {
            fillTypeXML = GpadStyleMaps.FILL_TYPE_MAP.get("symbols");
            if (fillTypeXML != null) {
                if (hatchAngle == null)
                    hatchAngle = "45";
                if (hatchDistance == null)
                    hatchDistance = "10";
            }
        }
        
        // Handle hatchAngle and hatchDistance constraints
        if (hatchAngle != null && hatchDistance == null)
            hatchDistance = "10";
        
        // Serialize this bar using helper class
        if (!GpadSerializer.serializeBarTagBar(serialized, barNumber, rgba, fillTypeXML,
                hatchAngle, hatchDistance, image, fillSymbol)) {
            // Serialization failed, skip this bar
            return;
        }
    }
}

/**
 * Command/Expression statement: label1* @style { inline_styles } ..., label2~ ... = ValidExpression
 * Function definition statement: f(var1, var2, ...)* @style1 {...} ... = expressionnode
 * * = hide both object and label
 * ~ = show object, hide label
 */
void gpadCommandExpression() throws GpadParseException :
{
    java.util.List<String> names = new java.util.ArrayList<>();
    Token equalToken = null;
    int[] pos = null;
    EvalInfo info;
    ValidExpression ve;
    GeoElement[] geos;

    java.util.List<GpadStyleSheet> styleSheets = new java.util.ArrayList<>();

    ExpressionNode rhs;
    ExpressionNode cond = null;
    Token funName = null;
    Token varName = null;
    Token assignmentOp = null;
    GpadStyleSheet styleSheet;
}
{
    try {
    (
        gpadLabelStyleSheets(names, styleSheets)
        ( <COMMA> gpadLabelStyleSheets(names, styleSheets) )*
        equalToken = <EQUAL> { pos = extractPositionFromToken(equalToken); }
        ve = expressionOrEquation() [<POLAR_SEPARATOR>]
        {
            ve.addLabel(names);
            info = new EvalInfo(true);
            geos = kernel.getAlgebraProcessor().processValidExpression(ve, info);
            for(int i=0; i<geos.length; i++) {
                GeoElement geo = geos[i];
                if (i >= 0 && i < styleSheets.size())
                    applyGeoStyleSheet(geo, styleSheets.get(i), pos[0], pos[1]);
                gpadResults.add(geo);
            }
        }
    )
    |
    (
        // single or multi-variable function definition
        // f(a) =  a^2 + 3
        // g(x,y) := x * y
        (
            funName = <FUNCTION_LABEL> |  // includes "(" at end
            funName = <Z_FUNC> // includes "(" at end
        )
            // local variables, allow function of y and deal with it in GeoFunction constructor
            (( varName =  <VARX> | varName =  <VARY> | varName = label() )
            { names.add(varName.image);
            kernel.getConstruction().registerFunctionVariable(varName.image);} )
            // optional second variable
            (<COMMA> ( varName = casVar() )
            {
                names.add(varName.image);
                kernel.getConstruction().registerFunctionVariable(varName.image);
            } )*
            // closing ) and assignment with expressionnode
        ")"
        styleSheet = gpadApplyStyleSheets()
        ( equalToken = <EQUAL > | assignmentOp = <ASSIGNMENT> )
        {
            if (equalToken == null)
                equalToken = assignmentOp;
            pos = extractPositionFromToken(equalToken);
        }
        rhs = expressionnode() (cond = conditions())? [<POLAR_SEPARATOR>]
        {
            String funLabel = funName.image.substring(0, funName.image.length() - 1);
            ve = functionParser.assignment(rhs, funLabel, names, cond, assignmentOp != null);
            info = new EvalInfo(true);
            geos = kernel.getAlgebraProcessor().processValidExpression(ve, info);
            if (geos.length >= 1) {
                if (styleSheet != null)
                    applyGeoStyleSheet(geos[0], styleSheet, pos[0], pos[1]);
                gpadResults.add(geos[0]);
            }
        }
    )
    } catch (CircularDefinitionException e) {
        // Catch CircularDefinitionException from expressionOrEquation() or processValidExpression()
        // Use equalToken position if available, otherwise try to get from current token
        if (pos == null || pos[0] < 0 || pos[1] < 0)
            pos = extractPositionFromToken(token);
        throw createGpadParseException(e, "Circular definition", pos[0], pos[1], false);
    } catch (org.geogebra.common.main.MyError e) {
        // Catch MyError from expressionOrEquation() or processValidExpression()
        // Use equalToken position if available, otherwise try to get from current token
        if (pos == null || pos[0] < 0 || pos[1] < 0)
            pos = extractPositionFromToken(token);
        throw createGpadParseException(e, "Error", pos[0], pos[1], false);
    } catch (ParseException e) {
        // Catch ParseException from expressionOrEquation()
        throw createGpadParseException(e);
    }
}

void gpadLabelStyleSheets(java.util.List<String> labels, java.util.List<GpadStyleSheet> styleSheets) :
{
    String label;
    GpadStyleSheet styleSheet;
}
{
    label = gpadGeoLabel()
    styleSheet = gpadApplyStyleSheets()
    {
        labels.add(label);
        styleSheets.add(styleSheet);
    }
}

String gpadGeoLabel() :
{
    Token tok;
}
{
    ( tok = <SPREADSHEET_LABEL> | tok = <LABEL> ) { return tok.image; }
}

GpadStyleSheet gpadApplyStyleSheets() :
{
    Token visibilityFlag = null;
    Token styleName;
    GpadStyleSheet styleSheet = null, styleSheet2;
}
{
    ( visibilityFlag = <MULTIPLY> | visibilityFlag = <TILDE> )?
    (
        (
        (styleName = <GSSLABEL> { styleSheet2 = gpadStyleSheets.get(styleName.image.substring(1)); })
        | (styleSheet2 = gpadStyleSheetBody(""))
        )
        {
            if (styleSheet == null)
                styleSheet = styleSheet2;
            else
                styleSheet.mergeFrom(styleSheet2);
        }
    )*
    {
        if(visibilityFlag != null) {
            styleSheet2 = new GpadStyleSheet("");
            java.util.LinkedHashMap<String, String> attrs = new java.util.LinkedHashMap<>();
            attrs.put("object", visibilityFlag.kind==MULTIPLY? "false": "true");
            attrs.put("label", "false");
            styleSheet2.setProperty("show", attrs);
            if(styleSheet == null)
                styleSheet = styleSheet2;
            else
                styleSheet.mergeFrom(styleSheet2);
        }
        return styleSheet;
    }
}

/**
 * Macro definition: @@macro name(input1, input2, ...) { gpadStatementInMacro* @@return output1, output2, ... }
 */
void gpadMacroDefinition() throws GpadParseException :
{
    Token macroNameToken;
    String macroName;
    java.util.List<String> inputLabels = new java.util.ArrayList<>();
    java.util.List<String> outputLabels = new java.util.ArrayList<>();
    Macro macro;
    MacroKernel macroKernel;
    org.geogebra.common.kernel.Construction macroCons;
    Kernel savedKernel;
    FunctionParser savedFunctionParser;
    java.util.List<GeoElement> savedResults;
    java.util.Map<String, GpadStyleSheet> savedStyleSheets;
}
{
    <GPAD_MACRO>
    macroNameToken = <FUNCTION_LABEL>
    {
        macroName = macroNameToken.image;
        macroName = macroName.substring(0, macroName.length() - 1);
        
        // Check for name conflict
        if (kernel.getMacro(macroName) != null) {
            String errorMsg = "Macro '" + macroName + "' already exists";
            org.geogebra.common.util.debug.Log.error("Gpad macro definition failed: " + errorMsg);
            throw createParseException(errorMsg, macroNameToken);
        }
        
        // Create MacroKernel
        macroKernel = kernel.newMacroKernel();
        macroKernel.setContinuous(false);
        macroCons = macroKernel.getConstruction();
        
        // Create Macro object
        macro = new Macro(kernel, macroName);
        
        // Save current context
        savedKernel = kernel;
        savedFunctionParser = functionParser;
        savedResults = gpadResults;
        savedStyleSheets = gpadStyleSheets;
        
        // Switch to macro kernel
        // Note: Create a new, isolated gpadStyleSheets map for the macro definition.
        // Stylesheets defined inside the macro will only be available within the macro,
        // and the macro can only reference stylesheets defined within itself.
        // The parser (this) will use the switched kernel automatically.
        kernel = macroKernel;
        // Update functionParser to use the new macroKernel
        functionParser = new FunctionParser(kernel, undecided);
        gpadResults = new java.util.ArrayList<>();
        gpadStyleSheets = new java.util.HashMap<>();
    }
    [ gpadMacroLabelList(inputLabels) ] ")"
    <LBRACE> ( gpadStatementInMacro() )*
    <GPAD_RETURN> gpadMacroLabelList(outputLabels) <RBRACE>
    {
        // Restore original context
        // The macro's isolated gpadStyleSheets is discarded here,
        // ensuring stylesheets defined in the macro don't affect the global scope.
        kernel = savedKernel;
        // Restore functionParser to use the original kernel
        functionParser = savedFunctionParser;
        gpadResults = savedResults;
        gpadStyleSheets = savedStyleSheets;
        
        // Verify input labels exist in macro construction
        String[] inputLabelsArray = inputLabels.toArray(new String[0]);
        for (String inputLabel : inputLabelsArray) {
            if (macroCons.lookupLabel(inputLabel) == null) {
                String errorMsg = "Input object '" + inputLabel + "' not found in macro body";
                throw createParseException(errorMsg, token);
            }
        }
        
        // Verify output labels exist in macro construction
        String[] outputLabelsArray = outputLabels.toArray(new String[0]);
        for (String outputLabel : outputLabelsArray) {
            if (macroCons.lookupLabel(outputLabel) == null) {
                String errorMsg = "Output object '" + outputLabel + "' not found in macro body";
                throw createParseException(errorMsg, token);
            }
        }
        
        // Initialize macro
        try {
            macro.initMacro(macroCons, inputLabelsArray, outputLabelsArray);
        } catch (Exception e) {
            org.geogebra.common.util.debug.Log.error("Gpad macro initialization failed: " + e.getMessage());
            String errorMsg = "Failed to initialize macro: " + e.getMessage();
            throw createParseException(errorMsg, token);
        }
        
        // Register macro to kernel
        kernel.addMacro(macro);
    }
}

/**
 * Parses macro label list: label1, label2, ...
 */
void gpadMacroLabelList(java.util.List<String> labels) :
{
    String label;
}
{
    label = gpadGeoLabel() { labels.add(label); }
    ( <COMMA> label = gpadGeoLabel() { labels.add(label); } )*
}
